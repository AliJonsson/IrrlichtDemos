// PostProcessing Shaders
// David Evans, 2009

// Some of these are taken from the Irrlicht forums and modified to fit a common style. A couple could be optimized but they are fairly fast overall.

#define GL_V_FULLSCREEN "varying vec2 mTC;void main(void){gl_Position=vec4(gl_Vertex.xy,0.0,1.0);mTC=gl_MultiTexCoord0.xy;}"

#define GL_DIRECT "varying vec2 mTC;uniform sampler2D texture1;void main(void){gl_FragColor=texture2D(texture1,mTC);}"
#define GL_BLACK "void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);}"
#define GL_DARKEN "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=texture2D(texture1,mTC)*vecValue0;}"
#define GL_LIGHTEN "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=1.0-vecValue0+texture2D(texture1,mTC)*vecValue0;}"
#define GL_RANGE "uniform float vecValue0,vecValue1;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=(texture2D(texture1,mTC)-vecValue0)/(vecValue1-vecValue0);}"
#define GL_INVERT "uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=1.0-texture2D(texture1,mTC);}"
#define GL_HBLUR "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=(texture2D(texture1,mTC)+texture2D(texture1,vec2(mTC.x+vecValue0*0.5,mTC.y))+texture2D(texture1,vec2(mTC.x-vecValue0*0.5,mTC.y))+texture2D(texture1,vec2(mTC.x+vecValue0,mTC.y))+texture2D(texture1,vec2(mTC.x-vecValue0,mTC.y)))/5.0;}"
#define GL_VBLUR "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=(texture2D(texture1,mTC)+texture2D(texture1,vec2(mTC.x,mTC.y+vecValue0*0.5))+texture2D(texture1,vec2(mTC.x,mTC.y-vecValue0*0.5))+texture2D(texture1,vec2(mTC.x,mTC.y+vecValue0))+texture2D(texture1,vec2(mTC.x,mTC.y-vecValue0)))/5.0;}"
#define GL_LINEARBLUR "uniform float vecValue0,vecValue1;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=(texture2D(texture1,mTC)+texture2D(texture1,vec2(mTC.x+vecValue0*0.5,mTC.y+vecValue1*0.5))+texture2D(texture1,vec2(mTC.x-vecValue0*0.5,mTC.y-vecValue1*0.5))+texture2D(texture1,vec2(mTC.x+vecValue0,mTC.y+vecValue1))+texture2D(texture1,vec2(mTC.x-vecValue0,mTC.y-vecValue1)))/5.0;}"
#define GL_RADIALBLUR "uniform float vecValue0,vecValue1,vecValue2,vecValue3;uniform sampler2D texture1;varying vec2 mTC;void main(){vec2 d=vec2((mTC.x-vecValue0)*vecValue2*4.0,(mTC.y-vecValue1)*vecValue3*4.0);gl_FragColor=(texture2D(texture1,mTC)+texture2D(texture1,mTC-d*0.25)+texture2D(texture1,mTC-d*0.5)+texture2D(texture1,mTC-d*0.75)+texture2D(texture1,mTC-d))/5.0;}"
#define GL_HBLURFINE "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){vec4 Color=texture2D(texture1,mTC);for(float i=1.0;i>0.01;i-=0.2)Color+=texture2D(texture1,vec2(mTC.x+i*vecValue0,mTC.y))+texture2D(texture1,vec2(mTC.x-i*vecValue0,mTC.y));gl_FragColor=Color/11.0;}"
#define GL_VBLURFINE "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){vec4 Color=texture2D(texture1,mTC);for(float i=1.0;i>0.01;i-=0.2)Color+=texture2D(texture1,vec2(mTC.x,mTC.y+i*vecValue0))+texture2D(texture1,vec2(mTC.x,mTC.y-i*vecValue0));gl_FragColor=Color/11.0;}"
#define GL_LINEARBLURFINE "uniform float vecValue0,vecValue1;uniform sampler2D texture1;varying vec2 mTC;void main(){vec4 Color=texture2D(texture1,mTC);for(float i=1.0;i>0.01;i-=0.2)Color+=texture2D(texture1,vec2(mTC.x+i*vecValue0,mTC.y+i*vecValue1))+texture2D(texture1,vec2(mTC.x-i*vecValue0,mTC.y-i*vecValue1));gl_FragColor=Color/11.0;}"
#define GL_RADIALBLURFINE "uniform float vecValue0,vecValue1,vecValue2,vecValue3;uniform sampler2D texture1;varying vec2 mTC;void main(){vec2 d=vec2((mTC.x-vecValue0)*vecValue2*4.0,(mTC.y-vecValue1)*vecValue3*4.0);vec4 Color=texture2D(texture1,mTC);for(float i=1.0;i>0.01;i-=0.1)Color+=texture2D(texture1,mTC-d*i);gl_FragColor=Color/11.0;}"
#define GL_OVERLAY "uniform float vecValue0;uniform sampler2D texture1,texture2;varying vec2 mTC;void main(){gl_FragColor=texture2D(texture1,mTC)+texture2D(texture2,mTC)*vecValue0;}"
#define GL_OVERLAY2 "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=texture2D(texture1,mTC)*vecValue0;}"
#define GL_OVERLAYNEG "uniform float vecValue0;uniform sampler2D texture1,texture2;varying vec2 mTC;void main(){gl_FragColor=texture2D(texture1,mTC)-vecValue0+texture2D(texture2,mTC)*vecValue0;}"
#define GL_OVERLAYNEG2 "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=vecValue0-texture2D(texture1,mTC)*vecValue0;}"
#define GL_MOTIONBLUR "uniform float vecValue0;uniform sampler2D texture1,texture2;varying vec2 mTC;void main(){gl_FragColor=texture2D(texture1,mTC)*(1.0-vecValue0)+texture2D(texture2,mTC)*vecValue0;}"
#define GL_MOTIONBLUR2 "uniform float vecValue0;uniform sampler2D texture1;varying vec2 mTC;void main(){gl_FragColor=vec4(texture2D(texture1,mTC).xyz,vecValue0);}"
#define GL_TINT "uniform float vecValue0,vecValue1,vecValue2;uniform sampler2D texture1;varying vec2 mTC;void main(){float c=dot(texture2D(texture1,mTC),vec4(0.2,0.5,0.3,0.0));gl_FragColor=vec4(pow(c,1.0/vecValue0),pow(c,1.0/vecValue1),pow(c,1.0/vecValue2),1.0);}"
#define GL_CURVES "uniform float vecValue0,vecValue1,vecValue2;uniform sampler2D texture1;varying vec2 mTC;void main(){vec4 c=texture2D(texture1,mTC);gl_FragColor=vec4(pow(c.x,1.0/vecValue0),pow(c.y,1.0/vecValue1),pow(c.z,1.0/vecValue2),1.0);}"
#define GL_NOISE "uniform float randNum,vecValue0;varying vec2 mTC;uniform sampler2D texture1;float rand(in float s){return sin(mTC.x*(1009.0+s*10.0)+tan(mTC.y*(1090.0+s*100.0)+tan(mTC.x*111.0+s*10000.0))+s*4.0+mTC.y*10000.0)*0.5+0.5;}void main(void){gl_FragColor=texture2D(texture1,mTC)+vec4(rand(randNum))*vecValue0;}"
#define GL_DEPTH "uniform sampler2D texture1;varying vec2 mTC;void main(void){gl_FragColor=vec4(texture2D(texture1,mTC).w);}"
#define GL_COLORNOISE "uniform float randNum,vecValue0;varying vec2 mTC;uniform sampler2D texture1;float rand(in float s){return sin(mTC.x*(1009.0+s*10.0)+tan(mTC.y*(1090.0+s*100.0)+tan(mTC.x*111.0+s*10000.0))+s*4.0+mTC.y*10000.0)*0.5+0.5;}void main(void){gl_FragColor=texture2D(texture1,mTC)+vec4(rand(randNum),rand(randNum+0.2),rand(randNum+0.6),0.0)*vecValue0;}"
// Occlusion taken from an example on the Irrlicht forums and mutilated. Uses alpha as depth.
#define GL_OCCLUSION "uniform sampler2D texture1;uniform float vecValue0,vecValue1,vecValue2;varying vec2 mTC;float dat(in vec2 p){return texture2D(texture1,p).w;}void main(void){vec2 px=vec2(vecValue0,vecValue1);float m=vecValue2,depth=dat(mTC),ao=clamp((depth-dat(mTC+px))*m,0.0,1.0)+clamp((depth-dat(mTC+vec2(px.x,-px.y)))*m,0.0,1.0)+clamp((depth-dat(mTC-px))*m,0.0,1.0)+clamp((depth-dat(mTC+vec2(-px.x,px.y)))*m,0.0,1.0);px*=2.0;m*=0.5;ao+=clamp((depth-dat(mTC+px))*m,0.0,1.0)+clamp((depth-dat(mTC+vec2(px.x,-px.y)))*m,0.0,1.0)+clamp((depth-dat(mTC-px))*m,0.0,1.0)+clamp((depth-dat(mTC+vec2(-px.x,px.y)))*m,0.0,1.0);px*=2.0;m*=0.5;ao+=clamp((depth-dat(mTC+px))*m,0.0,1.0)+clamp((depth-dat(mTC+vec2(px.x,-px.y)))*m,0.0,1.0)+clamp((depth-dat(mTC-px))*m,0.0,1.0)+clamp((depth-dat(mTC+vec2(-px.x,px.y)))*m,0.0,1.0);px*=2.0;m*=0.5;ao+=clamp((depth-dat(mTC+px))*m,0.0,1.0)+clamp((depth-dat(mTC+vec2(px.x,-px.y)))*m,0.0,1.0)+clamp((depth-dat(mTC-px))*m,0.0,1.0)+clamp((depth-dat(mTC+vec2(-px.x,px.y)))*m,0.0,1.0);gl_FragColor=vec4((1.0-ao*0.0625)*texture2D(texture1,mTC).xyz,texture2D(texture1,mTC).w);}"
#define GL_TRANSMAP "uniform float vecValue0;uniform sampler2D texture1,texture2;varying vec2 mTC;void main(){gl_FragColor=vec4(texture2D(texture1,mTC).xyz,clamp(vecValue0-texture2D(texture2,mTC).x,0.0,0.1)*10.0);}"

#define GL_V_MAT "varying vec3 N,v;varying vec2 mTC;varying float s,z;void main(void){v=vec3(gl_ModelViewMatrix*gl_Vertex);N=normalize(gl_NormalMatrix*gl_Normal);s=pow(1.0+dot(N,normalize(v)),3.0);gl_Position=gl_ModelViewProjectionMatrix*gl_Vertex;z=gl_Position.z*0.01;mTC=gl_MultiTexCoord0.xy;}"

#define GL_WHITE "varying vec2 mTC;varying float z;void main(void){gl_FragColor=vec4(1.0,1.0,1.0,z);}"
#define GL_WHITE1 "varying vec3 N,v;varying vec2 mTC;varying float s,z;void main(void){gl_FragColor=vec4((gl_LightSource[0].ambient.xyz+gl_LightSource[0].diffuse.xyz*max(dot(N,normalize(gl_LightSource[0].position.xyz-v)),0.0)),z);}"
#define GL_WHITE2 "varying vec3 N,v;varying vec2 mTC;varying float s,z;void main(void){gl_FragColor=vec4((gl_LightSource[0].ambient.xyz+gl_LightSource[0].diffuse.xyz*max(dot(N,normalize(gl_LightSource[0].position.xyz-v)),0.0)+gl_LightSource[1].ambient.xyz+gl_LightSource[1].diffuse.xyz*max(dot(N,normalize(gl_LightSource[1].position.xyz-v)),0.0)),z);}"
#define GL_PLAIN "uniform sampler2D texture1;varying vec2 mTC;varying float z;void main(void){gl_FragColor=vec4(texture2D(texture1,mTC).xyz,z);}"
#define GL_PLAIN1 "uniform sampler2D texture1;varying vec3 N,v;varying vec2 mTC;varying float s,z;void main(void){gl_FragColor=vec4(texture2D(texture1,mTC).xyz*(gl_LightSource[0].ambient.xyz+gl_LightSource[0].diffuse.xyz*max(dot(N,normalize(gl_LightSource[0].position.xyz-v)),0.0)),z);}"
#define GL_PLAIN2 "uniform sampler2D texture1;varying vec3 N,v;varying vec2 mTC;varying float s,z;void main(void){gl_FragColor=vec4(texture2D(texture1,mTC).xyz*(gl_LightSource[0].ambient.xyz+gl_LightSource[0].diffuse.xyz*max(dot(N,normalize(gl_LightSource[0].position.xyz-v)),0.0)+gl_LightSource[1].ambient.xyz+gl_LightSource[1].diffuse.xyz*max(dot(N,normalize(gl_LightSource[1].position.xyz-v)),0.0)),z);}"
#define GL_FELT1 "uniform sampler2D texture1;varying vec3 N,v;varying vec2 mTC;varying float s,z;void main(void){gl_FragColor=vec4(vec3(0.1,0.2,0.3)*min(1.0,s)+texture2D(texture1,mTC).xyz*(gl_LightSource[0].ambient.xyz+gl_LightSource[0].diffuse.xyz*max(dot(N,normalize(gl_LightSource[0].position.xyz-v)),0.0)),z);}"
#define GL_FELT2 "uniform sampler2D texture1;varying vec3 N,v;varying vec2 mTC;varying float s,z;void main(void){gl_FragColor=vec4(vec3(0.1,0.2,0.3)*min(1.0,s)+texture2D(texture1,mTC).xyz*(gl_LightSource[0].ambient.xyz+gl_LightSource[0].diffuse.xyz*max(dot(N,normalize(gl_LightSource[0].position.xyz-v)),0.0)+gl_LightSource[1].ambient.xyz+gl_LightSource[1].diffuse.xyz*max(dot(N,normalize(gl_LightSource[1].position.xyz-v)),0.0)),z);}"

// I haven't got around to converting the shaders for directX yet. If you convert them yourself please post them on the forums!
#define DX_V_FULLSCREEN ""

#define DX_DIRECT ""
#define DX_BLACK ""
#define DX_DARKEN ""
#define DX_LIGHTEN ""
#define DX_RANGE ""
#define DX_INVERT ""
#define DX_HBLUR ""
#define DX_VBLUR ""
#define DX_LINEARBLUR ""
#define DX_RADIALBLUR ""
#define DX_HBLURFINE ""
#define DX_VBLURFINE ""
#define DX_LINEARBLURFINE ""
#define DX_RADIALBLURFINE ""
#define DX_OVERLAY ""
#define DX_OVERLAY2 ""
#define DX_OVERLAYNEG ""
#define DX_OVERLAYNEG2 ""
#define DX_MOTIONBLUR ""
#define DX_MOTIONBLUR2 ""
#define DX_TINT ""
#define DX_CURVES ""
#define DX_NOISE ""
#define DX_DEPTH ""
#define DX_COLORNOISE ""
#define DX_OCCLUSION ""
#define DX_TRANSMAP ""

#define DX_V_MAT ""

#define DX_WHITE ""
#define DX_WHITE1 ""
#define DX_WHITE2 ""
#define DX_PLAIN ""
#define DX_PLAIN1 ""
#define DX_PLAIN2 ""
#define DX_FELT1 ""
#define DX_FELT2 ""
