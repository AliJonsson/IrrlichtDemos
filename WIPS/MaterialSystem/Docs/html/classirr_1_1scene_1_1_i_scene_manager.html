<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Material System: irr::scene::ISceneManager Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="namespaceirr.html">irr</a>::<a class="el" href="namespaceirr_1_1scene.html">scene</a>::<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html">ISceneManager</a></div>
<h1>irr::scene::ISceneManager Class Reference</h1><!-- doxytag: class=<irr::scene::ISceneManager> -->All Scene nodes can be created only here.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_i_scene_manager_8h-source.html">ISceneManager.h</a>&gt;</code>
<p>
<a href="classirr_1_1scene_1_1_i_scene_manager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0"></a><!-- doxytag: member=<irr::scene::ISceneManager::~ISceneManager> ref=<a0> args=<()> -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a0">~ISceneManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IAnimatedMesh *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">getMesh</a> (const c8 *filename)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you want to remove a loaded mesh from the cache again, use removeMesh().  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IAnimatedMesh *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a2">getMesh</a> (io::IReadFile *file)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Works just as getMesh(const char* filename).  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3"></a><!-- doxytag: member=<irr::scene::ISceneManager::getMeshCache> ref=<a3> args=<()=0> -->
virtual IMeshCache *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a3">getMeshCache</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">With this interface, it is possible to manually add new loaded meshes (if <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">ISceneManager::getMesh()</a> is not sufficient), to remove them and to iterate through already loaded meshes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1_i_video_driver.html">video::IVideoDriver</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a4">getVideoDriver</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1_i_material_system.html">video::IMaterialSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a5">getMaterialSystem</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Material System.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual gui::IGUIEnvironment *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a6">getGUIEnvironment</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7"></a><!-- doxytag: member=<irr::scene::ISceneManager::addVolumeLightSceneNode> ref=<a7> args=<(ISceneNode *parent=0, s32 id=-1, const u32 subdivU=32, const u32 subdivV=32, const video::SColor foot=video::SColor(51, 0, 230, 180), const video::SColor tail=video::SColor(0, 0, 0, 0), const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0> -->
virtual IVolumeLightSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a7">addVolumeLightSceneNode</a> (ISceneNode *parent=0, s32 id=-1, const u32 subdivU=32, const u32 subdivV=32, const video::SColor foot=video::SColor(51, 0, 230, 180), const video::SColor tail=video::SColor(0, 0, 0, 0), const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Example Usage: scene::IVolumeLightSceneNode * n = smgr-&gt;addVolumeLightSceneNode(NULL, -1, 32, 32, //Subdivide U/V video::SColor(0, 180, 180, 180), //foot color video::SColor(0, 0, 0, 0) //tail color ); if (n) { n-&gt;setScale(core::vector3df(46.0f, 45.0f, 46.0f)); n-&gt;getMaterial(0).setTexture(0, smgr-&gt;<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a4">getVideoDriver()</a>-&gt;getTexture("lightFalloff.png")); }. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IMeshSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a8">addCubeSceneNode</a> (f32 size=10.0f, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">It is a simple cube of (1,1,1) size.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IMeshSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a9">addSphereSceneNode</a> (f32 radius=5.0f, s32 polyCount=16, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">It is a simple sphere.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IAnimatedMeshSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a10">addAnimatedMeshSceneNode</a> (IAnimatedMesh *mesh, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), bool alsoAddIfMeshPointerZero=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IMeshSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a11">addMeshSceneNode</a> (IMesh *mesh, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), bool alsoAddIfMeshPointerZero=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a12">addWaterSurfaceSceneNode</a> (IMesh *mesh, f32 waveHeight=2.0f, f32 waveSpeed=300.0f, f32 waveLength=10.0f, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks really good when the Material type EMT_TRANSPARENT_REFLECTION is used.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a13">addOctTreeSceneNode</a> (IAnimatedMesh *mesh, ISceneNode *parent=0, s32 id=-1, s32 minimalPolysPerNode=512, bool alsoAddIfMeshPointerZero=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This a good method for rendering scenes with lots of geometry.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a14">addOctTreeSceneNode</a> (IMesh *mesh, ISceneNode *parent=0, s32 id=-1, s32 minimalPolysPerNode=256, bool alsoAddIfMeshPointerZero=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This a good method for rendering scenes with lots of geometry.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ICameraSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a15">addCameraSceneNode</a> (ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;lookat=core::vector3df(0, 0, 100), s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This camera does not react on user input like for example the one created with <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a17">addCameraSceneNodeFPS()</a>.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ICameraSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a16">addCameraSceneNodeMaya</a> (ISceneNode *parent=0, f32 rotateSpeed=-1500.0f, f32 zoomSpeed=200.0f, f32 translationSpeed=1500.0f, s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a standard camera with an animator that provides mouse control similar to camera in the 3D Software Maya.  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ICameraSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a17">addCameraSceneNodeFPS</a> (ISceneNode *parent=0, f32 rotateSpeed=100.0f, f32 moveSpeed=.5f, s32 id=-1, SKeyMap *keyMapArray=0, s32 keyMapSize=0, bool noVerticalMovement=false, f32 jumpSpeed=0.f)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This FPS camera is intended to provide a demonstration of a camera that behaves like a typical First Person Shooter.  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ILightSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a18">addLightSceneNode</a> (ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), video::SColorf color=video::SColorf(1.0f, 1.0f, 1.0f), f32 radius=100.0f, s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The light will cast dynamic light on all other scene nodes in the scene, which have the material flag video::MTF_LIGHTING turned on.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IBillboardSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a19">addBillboardSceneNode</a> (ISceneNode *parent=0, const core::dimension2d&lt; f32 &gt; &amp;size=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1, video::SColor colorTop=0xFFFFFFFF, video::SColor colorBottom=0xFFFFFFFF)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A billboard is like a 3d sprite: A 2d element, which always looks to the camera.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a20">addSkyBoxSceneNode</a> (video::ITexture *top, video::ITexture *bottom, video::ITexture *left, video::ITexture *right, video::ITexture *front, video::ITexture *back, ISceneNode *parent=0, s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A skybox is a big cube with 6 textures on it and is drawn around the camera position.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a21">addSkyDomeSceneNode</a> (video::ITexture *texture, u32 horiRes=16, u32 vertRes=8, f64 texturePercentage=0.9, f64 spherePercentage=2.0, ISceneNode *parent=0, s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A skydome is a large (half-) sphere with a panoramic texture on the inside and is drawn around the camera position.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IParticleSystemSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a22">addParticleSystemSceneNode</a> (bool withDefaultEmitter=true, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITerrainSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a23">addTerrainSceneNode</a> (const c8 *heightMapFileName, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 maxLOD=5, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, s32 smoothFactor=0, bool addAlsoIfHeightmapEmpty=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This node implements is a simple terrain renderer which uses a technique known as geo mip mapping for reducing the detail of triangle blocks which are far away.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITerrainSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a24">addTerrainSceneNode</a> (io::IReadFile *heightMapFile, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 maxLOD=5, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, s32 smoothFactor=0, bool addAlsoIfHeightmapEmpty=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Just like the other <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a23">addTerrainSceneNode()</a> method, but takes an IReadFile pointer as parameter for the heightmap.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a25">addQuake3SceneNode</a> (IMeshBuffer *meshBuffer, const quake3::SShader *shader, ISceneNode *parent=0, s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Quake3 Scene renders multiple meshes for a specific HighLanguage Shader (Quake3 Style ).  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a26">addEmptySceneNode</a> (ISceneNode *parent=0, s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can be used for doing advanced transformations or structuring the scene graph.  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IDummyTransformationSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a27">addDummyTransformationSceneNode</a> (ISceneNode *parent=0, s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This scene node does not render itself, and does not respond to set/getPosition, set/getRotation and set/getScale.  <a href="#a27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28"></a><!-- doxytag: member=<irr::scene::ISceneManager::addTextSceneNode> ref=<a28> args=<(gui::IGUIFont *font, const wchar_t *text, video::SColor color=video::SColor(100, 255, 255, 255), ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1)=0> -->
virtual ITextSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a28">addTextSceneNode</a> (gui::IGUIFont *font, const wchar_t *text, video::SColor color=video::SColor(100, 255, 255, 255), ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a text scene node, which is able to display 2d text at a position in three dimensional space. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IBillboardTextSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a29">addBillboardTextSceneNode</a> (gui::IGUIFont *font, const wchar_t *text, ISceneNode *parent=0, const core::dimension2d&lt; f32 &gt; &amp;size=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1, video::SColor colorTop=0xFFFFFFFF, video::SColor colorBottom=0xFFFFFFFF)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IAnimatedMesh *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a30">addHillPlaneMesh</a> (const c8 *name, const core::dimension2d&lt; f32 &gt; &amp;tileSize, const core::dimension2d&lt; u32 &gt; &amp;tileCount, <a class="el" href="classirr_1_1video_1_1_s_material.html">video::SMaterial</a> *material=0, f32 hillHeight=0.0f, const core::dimension2d&lt; f32 &gt; &amp;countHills=core::dimension2d&lt; f32 &gt;(0.0f, 0.0f), const core::dimension2d&lt; f32 &gt; &amp;textureRepeatCount=core::dimension2d&lt; f32 &gt;(1.0f, 1.0f))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The mesh is generated on the fly and looks like a plane with some hills on it.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IAnimatedMesh *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a31">addTerrainMesh</a> (const c8 *meshname, video::IImage *texture, video::IImage *heightmap, const core::dimension2d&lt; f32 &gt; &amp;stretchSize=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), f32 maxHeight=200.0f, const core::dimension2d&lt; s32 &gt; &amp;defaultVertexBlockSize=core::dimension2d&lt; s32 &gt;(64, 64))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The mesh is generated on the fly from a texture file and a height map file.  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IAnimatedMesh *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a32">addArrowMesh</a> (const c8 *name, video::SColor vtxColor0=0xFFFFFFFF, video::SColor vtxColor1=0xFFFFFFFF, u32 tesselationCylinder=4, u32 tesselationCone=8, f32 height=1.f, f32 cylinderHeight=0.6f, f32 width0=0.05f, f32 width1=0.3f)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IAnimatedMesh *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a33">addSphereMesh</a> (const c8 *name, f32 radius=5.f, u32 polyCountX=16, u32 polyCountY=16)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a34">getRootSceneNode</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the scene node which is parent of all scene nodes.  <a href="#a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a35">getSceneNodeFromId</a> (s32 id, ISceneNode *start=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a36">getSceneNodeFromName</a> (const c8 *name, ISceneNode *start=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a37">getSceneNodeFromType</a> (scene::ESCENE_NODE_TYPE type, ISceneNode *start=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a38">getSceneNodesFromType</a> (ESCENE_NODE_TYPE type, core::array&lt; scene::ISceneNode * &gt; &amp;outNodes, ISceneNode *start=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ICameraSceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a39">getActiveCamera</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a40">setActiveCamera</a> (ICameraSceneNode *camera)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The previous active camera will be deactivated.  <a href="#a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a41"></a><!-- doxytag: member=<irr::scene::ISceneManager::setShadowColor> ref=<a41> args=<(video::SColor color=video::SColor(150, 0, 0, 0))=0> -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a41">setShadowColor</a> (video::SColor color=video::SColor(150, 0, 0, 0))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the color of stencil buffers shadows drawn by the scene manager. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a42"></a><!-- doxytag: member=<irr::scene::ISceneManager::getShadowColor> ref=<a42> args=<() const =0> -->
virtual video::SColor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a42">getShadowColor</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current color of shadows. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a43">registerNodeForRendering</a> (ISceneNode *node, <a class="el" href="namespaceirr_1_1scene.html#a8">E_SCENE_NODE_RENDER_PASS</a> pass=ESNRP_AUTOMATIC)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method should only be used by SceneNodes when they get a ISceneNode::OnRegisterSceneNode() call.  <a href="#a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a44">drawAll</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This can only be invoked between IVideoDriver::beginScene() and IVideoDriver::endScene().  <a href="#a44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNodeAnimator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a45">createRotationAnimator</a> (const core::vector3df &amp;rotationPerSecond)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNodeAnimator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a46">createFlyCircleAnimator</a> (const core::vector3df &amp;center=core::vector3df(0.f, 0.f, 0.f), f32 radius=100.f, f32 speed=0.001f, const core::vector3df &amp;direction=core::vector3df(0.f, 1.f, 0.f))=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNodeAnimator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a47">createFlyStraightAnimator</a> (const core::vector3df &amp;startPoint, const core::vector3df &amp;endPoint, u32 timeForWay, bool loop=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNodeAnimator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a48">createTextureAnimator</a> (const core::array&lt; video::ITexture * &gt; &amp;textures, s32 timePerFrame, bool loop=true)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNodeAnimator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a49">createDeleteAnimator</a> (u32 timeMs)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNodeAnimatorCollisionResponse *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a50">createCollisionResponseAnimator</a> (ITriangleSelector *world, ISceneNode *sceneNode, const core::vector3df &amp;ellipsoidRadius=core::vector3df(30, 60, 30), const core::vector3df &amp;gravityPerSecond=core::vector3df(0,-10.0f, 0), const core::vector3df &amp;ellipsoidTranslation=core::vector3df(0, 0, 0), f32 slidingValue=0.0005f)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See ISceneNodeAnimatorCollisionResponse for details.  <a href="#a50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ISceneNodeAnimator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a51">createFollowSplineAnimator</a> (s32 startTime, const core::array&lt; core::vector3df &gt; &amp;points, f32 speed=1.0f, f32 tightness=0.5f)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The animator modifies the position of the attached scene node to make it follow a hermite spline.  <a href="#a51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITriangleSelector *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a52">createTriangleSelector</a> (IMesh *mesh, ISceneNode *node)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triangle selectors can be used for doing collision detection.  <a href="#a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITriangleSelector *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a53">createTriangleSelectorFromBoundingBox</a> (ISceneNode *node)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triangle selectors can be used for doing collision detection.  <a href="#a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITriangleSelector *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a54">createOctTreeTriangleSelector</a> (IMesh *mesh, ISceneNode *node, s32 minimalPolysPerNode=32)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triangle selectors can be used for doing collision detection.  <a href="#a54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IMetaTriangleSelector *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a55">createMetaTriangleSelector</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A meta triangle selector is nothing more than a collection of one or more triangle selectors providing together the interface of one triangle selector.  <a href="#a55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITriangleSelector *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a56">createTerrainTriangleSelector</a> (ITerrainSceneNode *node, s32 LOD=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a57">addExternalMeshLoader</a> (IMeshLoader *externalLoader)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you want the engine to be extended with file formats it currently is not able to load (e.g.  <a href="#a57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a58"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneCollisionManager> ref=<a58> args=<()=0> -->
virtual ISceneCollisionManager *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a58">getSceneCollisionManager</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the scene collision manager. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a59"></a><!-- doxytag: member=<irr::scene::ISceneManager::getMeshManipulator> ref=<a59> args=<()=0> -->
virtual IMeshManipulator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a59">getMeshManipulator</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the mesh manipulator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a60">addToDeletionQueue</a> (ISceneNode *node)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scene node is immediatly deleted when it's secure.  <a href="#a60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a61"></a><!-- doxytag: member=<irr::scene::ISceneManager::postEventFromUser> ref=<a61> args=<(const SEvent &amp;event)=0> -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a61">postEventFromUser</a> (const SEvent &amp;event)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Usually you do not have to use this method, it is used by the internal engine. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a62"></a><!-- doxytag: member=<irr::scene::ISceneManager::clear> ref=<a62> args=<()=0> -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a62">clear</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All scene nodes are removed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual io::IAttributes *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a63">getParameters</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String parameters can be used by plugins and mesh loaders.  <a href="#a63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1scene.html#a8">E_SCENE_NODE_RENDER_PASS</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a64">getSceneNodeRenderPass</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All scene nodes are being rendered in a specific order.  <a href="#a64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a65"></a><!-- doxytag: member=<irr::scene::ISceneManager::getDefaultSceneNodeFactory> ref=<a65> args=<()=0> -->
virtual ISceneNodeFactory *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a65">getDefaultSceneNodeFactory</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the default scene node factory which can create all built in scene nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a66"></a><!-- doxytag: member=<irr::scene::ISceneManager::registerSceneNodeFactory> ref=<a66> args=<(ISceneNodeFactory *factoryToAdd)=0> -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a66">registerSceneNodeFactory</a> (ISceneNodeFactory *factoryToAdd)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this to extend the scene manager with new scene node types which it should be able to create automaticly, for example when loading data from xml files. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a67"></a><!-- doxytag: member=<irr::scene::ISceneManager::getRegisteredSceneNodeFactoryCount> ref=<a67> args=<() const =0> -->
virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a67">getRegisteredSceneNodeFactoryCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns amount of registered scene node factories. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a68"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneNodeFactory> ref=<a68> args=<(u32 index)=0> -->
virtual ISceneNodeFactory *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a68">getSceneNodeFactory</a> (u32 index)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a scene node factory by index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a69"></a><!-- doxytag: member=<irr::scene::ISceneManager::getDefaultSceneNodeAnimatorFactory> ref=<a69> args=<()=0> -->
virtual ISceneNodeAnimatorFactory *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a69">getDefaultSceneNodeAnimatorFactory</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the default scene node animator factory which can create all built-in scene node animators. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a70"></a><!-- doxytag: member=<irr::scene::ISceneManager::registerSceneNodeAnimatorFactory> ref=<a70> args=<(ISceneNodeAnimatorFactory *factoryToAdd)=0> -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a70">registerSceneNodeAnimatorFactory</a> (ISceneNodeAnimatorFactory *factoryToAdd)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this to extend the scene manager with new scene node animator types which it should be able to create automaticly, for example when loading data from xml files. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a71"></a><!-- doxytag: member=<irr::scene::ISceneManager::getRegisteredSceneNodeAnimatorFactoryCount> ref=<a71> args=<() const =0> -->
virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a71">getRegisteredSceneNodeAnimatorFactoryCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns amount of registered scene node animator factories. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a72"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneNodeAnimatorFactory> ref=<a72> args=<(u32 index)=0> -->
virtual ISceneNodeAnimatorFactory *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a72">getSceneNodeAnimatorFactory</a> (u32 index)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a scene node animator factory by index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a73"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneNodeTypeName> ref=<a73> args=<(ESCENE_NODE_TYPE type)=0> -->
virtual const c8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a73">getSceneNodeTypeName</a> (ESCENE_NODE_TYPE type)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a typename from a scene node type or null if not found. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a74"></a><!-- doxytag: member=<irr::scene::ISceneManager::addSceneNode> ref=<a74> args=<(const char *sceneNodeTypeName, ISceneNode *parent=0)=0> -->
virtual ISceneNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a74">addSceneNode</a> (const char *sceneNodeTypeName, ISceneNode *parent=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a scene node to the scene by name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html">ISceneManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a75">createNewSceneManager</a> (bool cloneContent=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This can be used to easily draw and/or store two independent scenes at the same time.  <a href="#a75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a76">saveScene</a> (const c8 *filename, ISceneUserDataSerializer *userDataSerializer=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scene nodes with the option isDebugObject set to true are not being saved.  <a href="#a76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a77">saveScene</a> (io::IWriteFile *file, ISceneUserDataSerializer *userDataSerializer=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scene nodes with the option isDebugObject set to true are not being saved.  <a href="#a77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a78">loadScene</a> (const c8 *filename, ISceneUserDataSerializer *userDataSerializer=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scene is usually load from an .irr file, an xml based format.  <a href="#a78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a79">loadScene</a> (io::IReadFile *file, ISceneUserDataSerializer *userDataSerializer=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scene is usually load from an .irr file, an xml based format.  <a href="#a79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a80"></a><!-- doxytag: member=<irr::scene::ISceneManager::createMeshWriter> ref=<a80> args=<(EMESH_WRITER_TYPE type)=0> -->
virtual IMeshWriter *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a80">createMeshWriter</a> (EMESH_WRITER_TYPE type)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note: You need to drop() the pointer after use again, see IReferenceCounted::drop() for details. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a81"></a><!-- doxytag: member=<irr::scene::ISceneManager::setAmbientLight> ref=<a81> args=<(const video::SColorf &amp;ambientColor)=0> -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a81">setAmbientLight</a> (const video::SColorf &amp;ambientColor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets ambient color of the scene. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a82"></a><!-- doxytag: member=<irr::scene::ISceneManager::getAmbientLight> ref=<a82> args=<() const =0> -->
virtual const video::SColorf &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a82">getAmbientLight</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns ambient color of the scene. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
All Scene nodes can be created only here. 
<p>
There is a always growing list of scene nodes for lots of purposes: Indoor rendering scene nodes like the Octree (<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a13">addOctTreeSceneNode()</a>) or the terrain renderer (<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a23">addTerrainSceneNode()</a>), different Camera scene nodes (<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a15">addCameraSceneNode()</a>, <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a16">addCameraSceneNodeMaya()</a>), scene nodes for Light (<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a18">addLightSceneNode()</a>), Billboards (<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a19">addBillboardSceneNode()</a>) and so on. A scene node is a node in the hierachical scene graph. Every scene node may have children, which are other scene nodes. Children move relative the their parents position. If the parent of a node is not visible, its children won't be visible, too. In this way, it is for example easily possible to attach a light to a moving car or to place a walking character on a moving platform on a moving ship. The SceneManager is also able to load 3d mesh files of different formats. Take a look at <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">getMesh()</a> to find out what formats are supported. And if these formats are not enough use <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a57">addExternalMeshLoader()</a> to add new formats to the engine.
<p>

<p>
Definition at line <a class="el" href="_i_scene_manager_8h-source.html#l00141">141</a> of file <a class="el" href="_i_scene_manager_8h-source.html">ISceneManager.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a10"></a><!-- doxytag: member=<irr::scene::ISceneManager::addAnimatedMeshSceneNode> ref=<a10> args=<(IAnimatedMesh *mesh, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), bool alsoAddIfMeshPointerZero=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IAnimatedMeshSceneNode* irr::scene::ISceneManager::addAnimatedMeshSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IAnimatedMesh *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rotation</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em> = <code>core::vector3df(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>alsoAddIfMeshPointerZero</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mesh,:</em>&nbsp;</td><td>Pointer to the loaded animated mesh to be displayed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation,:</em>&nbsp;</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale,:</em>&nbsp;</td><td>Initial scale of the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alsoAddIfMeshPointerZero,:</em>&nbsp;</td><td>Add the scene node even if a 0 pointer is passed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created scene node. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a32"></a><!-- doxytag: member=<irr::scene::ISceneManager::addArrowMesh> ref=<a32> args=<(const c8 *name, video::SColor vtxColor0=0xFFFFFFFF, video::SColor vtxColor1=0xFFFFFFFF, u32 tesselationCylinder=4, u32 tesselationCone=8, f32 height=1.f, f32 cylinderHeight=0.6f, f32 width0=0.05f, f32 width1=0.3f)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IAnimatedMesh* irr::scene::ISceneManager::addArrowMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>vtxColor0</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>vtxColor1</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>tesselationCylinder</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>tesselationCone</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>height</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>cylinderHeight</em> = <code>0.6f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>width0</em> = <code>0.05f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>width1</em> = <code>0.3f</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the mesh </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtxColor0</em>&nbsp;</td><td>color of the cylinder </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtxColor1</em>&nbsp;</td><td>color of the cone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tesselationCylinder</em>&nbsp;</td><td>Number of quads the cylinder side consists of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tesselationCone</em>&nbsp;</td><td>Number of triangles the cone's roof consits of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Total height of the arrow </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cylinderHeight</em>&nbsp;</td><td>Total height of the cylinder, should be lesser than total height </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width0</em>&nbsp;</td><td>Diameter of the cylinder </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width1</em>&nbsp;</td><td>Diameter of the cone's base, should be not smaller than the cylinder's diameter </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19"></a><!-- doxytag: member=<irr::scene::ISceneManager::addBillboardSceneNode> ref=<a19> args=<(ISceneNode *parent=0, const core::dimension2d&lt; f32 &gt; &amp;size=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1, video::SColor colorTop=0xFFFFFFFF, video::SColor colorBottom=0xFFFFFFFF)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IBillboardSceneNode* irr::scene::ISceneManager::addBillboardSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; f32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em> = <code>core::dimension2d&lt;&nbsp;f32&nbsp;&gt;(10.0f,&nbsp;10.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>colorTop</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>colorBottom</em> = <code>0xFFFFFFFF</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A billboard is like a 3d sprite: A 2d element, which always looks to the camera. 
<p>
It is usually used for things like explosions, fire, lensflares and things like that. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent scene node of the billboard. Can be null. If the parent moves, the billboard will move too. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the billboard will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size,:</em>&nbsp;</td><td>Size of the billboard. This size is 2 dimensional because a billboard only has width and height. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>An id of the node. This id can be used to identify the node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorTop,:</em>&nbsp;</td><td>The color of the vertices at the top of the billboard (default: white). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorBottom,:</em>&nbsp;</td><td>The color of the vertices at the bottom of the billboard (default: white). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the billboard if successful, otherwise NULL. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29"></a><!-- doxytag: member=<irr::scene::ISceneManager::addBillboardTextSceneNode> ref=<a29> args=<(gui::IGUIFont *font, const wchar_t *text, ISceneNode *parent=0, const core::dimension2d&lt; f32 &gt; &amp;size=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1, video::SColor colorTop=0xFFFFFFFF, video::SColor colorBottom=0xFFFFFFFF)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IBillboardTextSceneNode* irr::scene::ISceneManager::addBillboardTextSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">gui::IGUIFont *&nbsp;</td>
          <td class="mdname" nowrap> <em>font</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const wchar_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; f32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em> = <code>core::dimension2d&lt;&nbsp;f32&nbsp;&gt;(10.0f,&nbsp;10.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>colorTop</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>colorBottom</em> = <code>0xFFFFFFFF</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>font</em>&nbsp;</td><td>The font to use on the billboard. Pass 0 to use the GUI environment's default font. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to display on the billboard. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>The billboard's parent. Pass 0 to use the root scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The billboard's width and height. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>The billboards position relative to its parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorTop,:</em>&nbsp;</td><td>The color of the vertices at the top of the billboard (default: white). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorBottom,:</em>&nbsp;</td><td>The color of the vertices at the bottom of the billboard (default: white). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the billboard if successful, otherwise NULL. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15"></a><!-- doxytag: member=<irr::scene::ISceneManager::addCameraSceneNode> ref=<a15> args=<(ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;lookat=core::vector3df(0, 0, 100), s32 id=-1)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ICameraSceneNode* irr::scene::ISceneManager::addCameraSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lookat</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;100)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This camera does not react on user input like for example the one created with <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a17">addCameraSceneNodeFPS()</a>. 
<p>
If you want to move or animate it, use animators or the ISceneNode::setPosition(), ICameraSceneNode::setTarget() etc methods. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the camera will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lookat,:</em>&nbsp;</td><td>Position where the camera will look at. Also known as target. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent scene node of the camera. Can be null. If the parent moves, the camera will move too. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>id of the camera. This id can be used to identify the camera. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to interface to camera if successful, otherwise 0. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17"></a><!-- doxytag: member=<irr::scene::ISceneManager::addCameraSceneNodeFPS> ref=<a17> args=<(ISceneNode *parent=0, f32 rotateSpeed=100.0f, f32 moveSpeed=.5f, s32 id=-1, SKeyMap *keyMapArray=0, s32 keyMapSize=0, bool noVerticalMovement=false, f32 jumpSpeed=0.f)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ICameraSceneNode* irr::scene::ISceneManager::addCameraSceneNodeFPS           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>rotateSpeed</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>moveSpeed</em> = <code>.5f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SKeyMap *&nbsp;</td>
          <td class="mdname" nowrap> <em>keyMapArray</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>keyMapSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>noVerticalMovement</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>jumpSpeed</em> = <code>0.f</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This FPS camera is intended to provide a demonstration of a camera that behaves like a typical First Person Shooter. 
<p>
It is useful for simple demos and prototyping but is not intended to provide a full solution for a production quality game. It binds the camera scene node rotation to the look-at target;<dl compact><dt><b>See also:</b></dt><dd>ICameraSceneNode::bindTargetAndRotation(). With this camera, you look with the mouse, and move with cursor keys. If you want to change the key layout, you can specify your own keymap. For example to make the camera be controlled by the cursor keys AND the keys W,A,S, and D, do something like this: <div class="fragment"><pre class="fragment">                SKeyMap keyMap[8];
                keyMap[0].Action = EKA_MOVE_FORWARD;
                keyMap[0].KeyCode = KEY_UP;
                keyMap[1].Action = EKA_MOVE_FORWARD;
                keyMap[1].KeyCode = KEY_KEY_W;

                keyMap[2].Action = EKA_MOVE_BACKWARD;
                keyMap[2].KeyCode = KEY_DOWN;
                keyMap[3].Action = EKA_MOVE_BACKWARD;
                keyMap[3].KeyCode = KEY_KEY_S;

                keyMap[4].Action = EKA_STRAFE_LEFT;
                keyMap[4].KeyCode = KEY_LEFT;
                keyMap[5].Action = EKA_STRAFE_LEFT;
                keyMap[5].KeyCode = KEY_KEY_A;

                keyMap[6].Action = EKA_STRAFE_RIGHT;
                keyMap[6].KeyCode = KEY_RIGHT;
                keyMap[7].Action = EKA_STRAFE_RIGHT;
                keyMap[7].KeyCode = KEY_KEY_D;

                camera = sceneManager-&gt;addCameraSceneNodeFPS(0, 100, 500, -1, keyMap, 8);
</pre></div> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent scene node of the camera. Can be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotateSpeed,:</em>&nbsp;</td><td>Speed in degress with which the camera is rotated. This can be done only with the mouse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>moveSpeed,:</em>&nbsp;</td><td>Speed in units per millisecond with which the camera is moved. Movement is done with the cursor keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>id of the camera. This id can be used to identify the camera. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyMapArray,:</em>&nbsp;</td><td>Optional pointer to an array of a keymap, specifying what keys should be used to move the camera. If this is null, the default keymap is used. You can define actions more then one time in the array, to bind multiple keys to the same action. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keyMapSize,:</em>&nbsp;</td><td>Amount of items in the keymap array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>noVerticalMovement,:</em>&nbsp;</td><td>Setting this to true makes the camera only move within a horizontal plane, and disables vertical movement as known from most ego shooters. Default is 'false', with which it is possible to fly around in space, if no gravity is there. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>jumpSpeed,:</em>&nbsp;</td><td>Speed with which the camera is moved when jumping. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16"></a><!-- doxytag: member=<irr::scene::ISceneManager::addCameraSceneNodeMaya> ref=<a16> args=<(ISceneNode *parent=0, f32 rotateSpeed=-1500.0f, f32 zoomSpeed=200.0f, f32 translationSpeed=1500.0f, s32 id=-1)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ICameraSceneNode* irr::scene::ISceneManager::addCameraSceneNodeMaya           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>rotateSpeed</em> = <code>-1500.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>zoomSpeed</em> = <code>200.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>translationSpeed</em> = <code>1500.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a standard camera with an animator that provides mouse control similar to camera in the 3D Software Maya. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent scene node of the camera. Can be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotateSpeed,:</em>&nbsp;</td><td>Rotation speed of the camera. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zoomSpeed,:</em>&nbsp;</td><td>Zoom speed of the camera. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>translationSpeed,:</em>&nbsp;</td><td>Translation speed of the camera. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>id of the camera. This id can be used to identify the camera. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8"></a><!-- doxytag: member=<irr::scene::ISceneManager::addCubeSceneNode> ref=<a8> args=<(f32 size=10.0f, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IMeshSceneNode* irr::scene::ISceneManager::addCubeSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">f32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em> = <code>10.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rotation</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em> = <code>core::vector3df(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It is a simple cube of (1,1,1) size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size,:</em>&nbsp;</td><td>Size of the cube. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation,:</em>&nbsp;</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale,:</em>&nbsp;</td><td>Initial scale of the scene node. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created test scene node. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27"></a><!-- doxytag: member=<irr::scene::ISceneManager::addDummyTransformationSceneNode> ref=<a27> args=<(ISceneNode *parent=0, s32 id=-1)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IDummyTransformationSceneNode* irr::scene::ISceneManager::addDummyTransformationSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This scene node does not render itself, and does not respond to set/getPosition, set/getRotation and set/getScale. 
<p>
Its just a simple scene node that takes a matrix as relative transformation, making it possible to insert any transformation anywhere into the scene graph. <dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created scene node. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26"></a><!-- doxytag: member=<irr::scene::ISceneManager::addEmptySceneNode> ref=<a26> args=<(ISceneNode *parent=0, s32 id=-1)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::addEmptySceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Can be used for doing advanced transformations or structuring the scene graph. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created scene node. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a57"></a><!-- doxytag: member=<irr::scene::ISceneManager::addExternalMeshLoader> ref=<a57> args=<(IMeshLoader *externalLoader)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::scene::ISceneManager::addExternalMeshLoader           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IMeshLoader *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>externalLoader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If you want the engine to be extended with file formats it currently is not able to load (e.g. 
<p>
.cob), just implement the IMeshLoader interface in your loading class and add it with this method. Using this method it is also possible to override built-in mesh loaders with newer or updated versions without the need of recompiling the engine. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>externalLoader,:</em>&nbsp;</td><td>Implementation of a new mesh loader. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30"></a><!-- doxytag: member=<irr::scene::ISceneManager::addHillPlaneMesh> ref=<a30> args=<(const c8 *name, const core::dimension2d&lt; f32 &gt; &amp;tileSize, const core::dimension2d&lt; u32 &gt; &amp;tileCount, video::SMaterial *material=0, f32 hillHeight=0.0f, const core::dimension2d&lt; f32 &gt; &amp;countHills=core::dimension2d&lt; f32 &gt;(0.0f, 0.0f), const core::dimension2d&lt; f32 &gt; &amp;textureRepeatCount=core::dimension2d&lt; f32 &gt;(1.0f, 1.0f))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IAnimatedMesh* irr::scene::ISceneManager::addHillPlaneMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; f32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; u32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tileCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classirr_1_1video_1_1_s_material.html">video::SMaterial</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>material</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>hillHeight</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; f32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>countHills</em> = <code>core::dimension2d&lt;&nbsp;f32&nbsp;&gt;(0.0f,&nbsp;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; f32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>textureRepeatCount</em> = <code>core::dimension2d&lt;&nbsp;f32&nbsp;&gt;(1.0f,&nbsp;1.0f)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The mesh is generated on the fly and looks like a plane with some hills on it. 
<p>
It is uses mostly for quick tests of the engine only. You can specify how many hills there should be on the plane and how high they should be. Also you must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retrieved again using <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">ISceneManager::getMesh()</a> with the name as parameter. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name,:</em>&nbsp;</td><td>The name of this mesh which must be specified in order to be able to retrieve the mesh later with <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">ISceneManager::getMesh()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tileSize,:</em>&nbsp;</td><td>Size of a tile of the mesh. (10.0f, 10.0f) would be a good value to start, for example. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tileCount,:</em>&nbsp;</td><td>Specifies how much tiles there will be. If you specifiy for example that a tile has the size (10.0f, 10.0f) and the tileCount is (10,10), than you get a field of 100 tiles which has the dimension 100.0fx100.0f. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>material,:</em>&nbsp;</td><td>Material of the hill mesh. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hillHeight,:</em>&nbsp;</td><td>Height of the hills. If you specify a negative value you will get holes instead of hills. If the height is 0, no hills will be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>countHills,:</em>&nbsp;</td><td>Amount of hills on the plane. There will be countHills.X hills along the X axis and countHills.Y along the Y axis. So in total there will be countHills.X * countHills.Y hills. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>textureRepeatCount,:</em>&nbsp;</td><td>Defines how often the texture will be repeated in x and y direction. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns null if the creation failed. The reason could be that you specified some invalid parameters or that a mesh with that name already exists. If successful, a pointer to the mesh is returned. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18"></a><!-- doxytag: member=<irr::scene::ISceneManager::addLightSceneNode> ref=<a18> args=<(ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), video::SColorf color=video::SColorf(1.0f, 1.0f, 1.0f), f32 radius=100.0f, s32 id=-1)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ILightSceneNode* irr::scene::ISceneManager::addLightSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColorf&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>video::SColorf(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The light will cast dynamic light on all other scene nodes in the scene, which have the material flag video::MTF_LIGHTING turned on. 
<p>
(This is the default setting in most scene nodes). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent scene node of the light. Can be null. If the parent moves, the light will move too. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the light will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color,:</em>&nbsp;</td><td>Diffuse color of the light. Ambient or Specular colors can be set manually with the ILightSceneNode::getLightData() method. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius,:</em>&nbsp;</td><td>Radius of the light. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>id of the node. This id can be used to identify the node. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the interface of the light if successful, otherwise NULL. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11"></a><!-- doxytag: member=<irr::scene::ISceneManager::addMeshSceneNode> ref=<a11> args=<(IMesh *mesh, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), bool alsoAddIfMeshPointerZero=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IMeshSceneNode* irr::scene::ISceneManager::addMeshSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IMesh *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rotation</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em> = <code>core::vector3df(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>alsoAddIfMeshPointerZero</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mesh,:</em>&nbsp;</td><td>Pointer to the loaded static mesh to be displayed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation,:</em>&nbsp;</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale,:</em>&nbsp;</td><td>Initial scale of the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alsoAddIfMeshPointerZero,:</em>&nbsp;</td><td>Add the scene node even if a 0 pointer is passed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created scene node. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14"></a><!-- doxytag: member=<irr::scene::ISceneManager::addOctTreeSceneNode> ref=<a14> args=<(IMesh *mesh, ISceneNode *parent=0, s32 id=-1, s32 minimalPolysPerNode=256, bool alsoAddIfMeshPointerZero=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::addOctTreeSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IMesh *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>minimalPolysPerNode</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>alsoAddIfMeshPointerZero</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This a good method for rendering scenes with lots of geometry. 
<p>
The Octree is built on the fly from the mesh, much faster then a bsp tree. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mesh,:</em>&nbsp;</td><td>The mesh containing all geometry from which the octtree will be build. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent node of the octtree node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>id of the node. This id can be used to identify the node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimalPolysPerNode,:</em>&nbsp;</td><td>Specifies the minimal polygons contained a octree node. If a node gets less polys than this value it will not be split into smaller nodes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alsoAddIfMeshPointerZero,:</em>&nbsp;</td><td>Add the scene node even if a 0 pointer is passed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the octtree if successful, otherwise 0. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member=<irr::scene::ISceneManager::addOctTreeSceneNode> ref=<a13> args=<(IAnimatedMesh *mesh, ISceneNode *parent=0, s32 id=-1, s32 minimalPolysPerNode=512, bool alsoAddIfMeshPointerZero=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::addOctTreeSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IAnimatedMesh *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>minimalPolysPerNode</em> = <code>512</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>alsoAddIfMeshPointerZero</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This a good method for rendering scenes with lots of geometry. 
<p>
The Octree is built on the fly from the mesh. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mesh,:</em>&nbsp;</td><td>The mesh containing all geometry from which the octtree will be build. If this animated mesh has more than one frames in it, the first frame is taken. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent node of the octtree node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>id of the node. This id can be used to identify the node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimalPolysPerNode,:</em>&nbsp;</td><td>Specifies the minimal polygons contained a octree node. If a node gets less polys than this value it will not be split into smaller nodes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alsoAddIfMeshPointerZero,:</em>&nbsp;</td><td>Add the scene node even if a 0 pointer is passed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the OctTree if successful, otherwise 0. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22"></a><!-- doxytag: member=<irr::scene::ISceneManager::addParticleSystemSceneNode> ref=<a22> args=<(bool withDefaultEmitter=true, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IParticleSystemSceneNode* irr::scene::ISceneManager::addParticleSystemSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname" nowrap> <em>withDefaultEmitter</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rotation</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em> = <code>core::vector3df(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>withDefaultEmitter,:</em>&nbsp;</td><td>Creates a default working point emitter which emitts some particles. Set this to true to see a particle system in action. If set to false, you'll have to set the emitter you want by calling IParticleSystemSceneNode::setEmitter(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation,:</em>&nbsp;</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale,:</em>&nbsp;</td><td>Initial scale of the scene node. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created scene node. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25"></a><!-- doxytag: member=<irr::scene::ISceneManager::addQuake3SceneNode> ref=<a25> args=<(IMeshBuffer *meshBuffer, const quake3::SShader *shader, ISceneNode *parent=0, s32 id=-1)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::addQuake3SceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IMeshBuffer *&nbsp;</td>
          <td class="mdname" nowrap> <em>meshBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const quake3::SShader *&nbsp;</td>
          <td class="mdname" nowrap> <em>shader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A Quake3 Scene renders multiple meshes for a specific HighLanguage Shader (Quake3 Style ). 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the <a class="el" href="namespaceirr_1_1scene_1_1quake3.html">quake3</a> scene node if successful, otherwise NULL. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20"></a><!-- doxytag: member=<irr::scene::ISceneManager::addSkyBoxSceneNode> ref=<a20> args=<(video::ITexture *top, video::ITexture *bottom, video::ITexture *left, video::ITexture *right, video::ITexture *front, video::ITexture *back, ISceneNode *parent=0, s32 id=-1)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::addSkyBoxSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>front</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>back</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A skybox is a big cube with 6 textures on it and is drawn around the camera position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>top,:</em>&nbsp;</td><td>Texture for the top plane of the box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bottom,:</em>&nbsp;</td><td>Texture for the bottom plane of the box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left,:</em>&nbsp;</td><td>Texture for the left plane of the box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right,:</em>&nbsp;</td><td>Texture for the right plane of the box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>front,:</em>&nbsp;</td><td>Texture for the front plane of the box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>back,:</em>&nbsp;</td><td>Texture for the back plane of the box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent scene node of the skybox. A skybox usually has no parent, so this should be null. Note: If a parent is set to the skybox, the box will not change how it is drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>An id of the node. This id can be used to identify the node. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the sky box if successful, otherwise NULL. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21"></a><!-- doxytag: member=<irr::scene::ISceneManager::addSkyDomeSceneNode> ref=<a21> args=<(video::ITexture *texture, u32 horiRes=16, u32 vertRes=8, f64 texturePercentage=0.9, f64 spherePercentage=2.0, ISceneNode *parent=0, s32 id=-1)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::addSkyDomeSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>horiRes</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>vertRes</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f64&nbsp;</td>
          <td class="mdname" nowrap> <em>texturePercentage</em> = <code>0.9</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f64&nbsp;</td>
          <td class="mdname" nowrap> <em>spherePercentage</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A skydome is a large (half-) sphere with a panoramic texture on the inside and is drawn around the camera position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture,:</em>&nbsp;</td><td>Texture for the dome. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>horiRes,:</em>&nbsp;</td><td>Number of vertices of a horizontal layer of the sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertRes,:</em>&nbsp;</td><td>Number of vertices of a vertical layer of the sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texturePercentage,:</em>&nbsp;</td><td>How much of the height of the texture is used. Should be between 0 and 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spherePercentage,:</em>&nbsp;</td><td>How much of the sphere is drawn. Value should be between 0 and 2, where 1 is an exact half-sphere and 2 is a full sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent scene node of the dome. A dome usually has no parent, so this should be null. Note: If a parent is set, the dome will not change how it is drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>An id of the node. This id can be used to identify the node. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the sky dome if successful, otherwise NULL. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33"></a><!-- doxytag: member=<irr::scene::ISceneManager::addSphereMesh> ref=<a33> args=<(const c8 *name, f32 radius=5.f, u32 polyCountX=16, u32 polyCountY=16)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IAnimatedMesh* irr::scene::ISceneManager::addSphereMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em> = <code>5.f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>polyCountX</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>polyCountY</em> = <code>16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the mesh </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>Radius of the sphere </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyCountX</em>&nbsp;</td><td>Number of quads used for the horizontal tiling </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyCountY</em>&nbsp;</td><td>Number of quads used for the vertical tiling </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9"></a><!-- doxytag: member=<irr::scene::ISceneManager::addSphereSceneNode> ref=<a9> args=<(f32 radius=5.0f, s32 polyCount=16, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IMeshSceneNode* irr::scene::ISceneManager::addSphereSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">f32&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em> = <code>5.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>polyCount</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rotation</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em> = <code>core::vector3df(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
It is a simple sphere. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radius,:</em>&nbsp;</td><td>Radius of the sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyCount,:</em>&nbsp;</td><td>Polycount of the sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation,:</em>&nbsp;</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale,:</em>&nbsp;</td><td>Initial scale of the scene node. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created test scene node. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31"></a><!-- doxytag: member=<irr::scene::ISceneManager::addTerrainMesh> ref=<a31> args=<(const c8 *meshname, video::IImage *texture, video::IImage *heightmap, const core::dimension2d&lt; f32 &gt; &amp;stretchSize=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), f32 maxHeight=200.0f, const core::dimension2d&lt; s32 &gt; &amp;defaultVertexBlockSize=core::dimension2d&lt; s32 &gt;(64, 64))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IAnimatedMesh* irr::scene::ISceneManager::addTerrainMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>meshname</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::IImage *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::IImage *&nbsp;</td>
          <td class="mdname" nowrap> <em>heightmap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; f32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>stretchSize</em> = <code>core::dimension2d&lt;&nbsp;f32&nbsp;&gt;(10.0f,&nbsp;10.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>maxHeight</em> = <code>200.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>defaultVertexBlockSize</em> = <code>core::dimension2d&lt;&nbsp;s32&nbsp;&gt;(64,&nbsp;64)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The mesh is generated on the fly from a texture file and a height map file. 
<p>
Both files may be huge (8000x8000 pixels would be no problem) because the generator splits the files into smaller textures if necessary. You must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retrieved again using <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">ISceneManager::getMesh()</a> with the name as parameter. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>meshname,:</em>&nbsp;</td><td>The name of this mesh which must be specified in order to be able to retrieve the mesh later with <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">ISceneManager::getMesh()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texture,:</em>&nbsp;</td><td>Texture for the terrain. Please note that this is not a hardware texture as usual (ITexture), but an IImage software texture. You can load this texture with IVideoDriver::createImageFromFile(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>heightmap,:</em>&nbsp;</td><td>A grayscaled heightmap image. Like the texture, it can be created with IVideoDriver::createImageFromFile(). The amount of triangles created depends on the size of this texture, so use a small heightmap to increase rendering speed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stretchSize,:</em>&nbsp;</td><td>Parameter defining how big a is pixel on the heightmap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxHeight,:</em>&nbsp;</td><td>Defines how high a white pixel on the heighmap is. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>defaultVertexBlockSize,:</em>&nbsp;</td><td>Defines the initial dimension between vertices. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns null if the creation failed. The reason could be that you specified some invalid parameters, that a mesh with that name already exists, or that a texture could not be found. If successful, a pointer to the mesh is returned. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24"></a><!-- doxytag: member=<irr::scene::ISceneManager::addTerrainSceneNode> ref=<a24> args=<(io::IReadFile *heightMapFile, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 maxLOD=5, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, s32 smoothFactor=0, bool addAlsoIfHeightmapEmpty=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITerrainSceneNode* irr::scene::ISceneManager::addTerrainSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">io::IReadFile *&nbsp;</td>
          <td class="mdname" nowrap> <em>heightMapFile</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0.0f,&nbsp;0.0f,&nbsp;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rotation</em> = <code>core::vector3df(0.0f,&nbsp;0.0f,&nbsp;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em> = <code>core::vector3df(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexColor</em> = <code>video::SColor(255,&nbsp;255,&nbsp;255,&nbsp;255)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>maxLOD</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>E_TERRAIN_PATCH_SIZE&nbsp;</td>
          <td class="mdname" nowrap> <em>patchSize</em> = <code>ETPS_17</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>smoothFactor</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>addAlsoIfHeightmapEmpty</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Just like the other <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a23">addTerrainSceneNode()</a> method, but takes an IReadFile pointer as parameter for the heightmap. 
<p>
For more informations take a look at the other function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heightMapFile,:</em>&nbsp;</td><td>The file handle to read vertex data from. This should be a gray scale bitmap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent of the scene node. Can be 0 if no parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>The absolute position of this node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation,:</em>&nbsp;</td><td>The absolute rotation of this node. ( NOT YET IMPLEMENTED ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale,:</em>&nbsp;</td><td>The scale factor for the terrain. If you're using a heightmap of size 129x129 and would like your terrain to be 12900x12900 in game units, then use a scale factor of ( core::vector ( 100.0f, 100.0f, 100.0f ). If you use a Y scaling factor of 0.0f, then your terrain will be flat. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexColor,:</em>&nbsp;</td><td>The default color of all the vertices. If no texture is associated with the scene node, then all vertices will be this color. Defaults to white. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxLOD,:</em>&nbsp;</td><td>The maximum LOD (level of detail) for the node. Only change if you know what you are doing, this might lead to strange behaviour. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patchSize,:</em>&nbsp;</td><td>patch size of the terrain. Only change if you know what you are doing, this might lead to strange behaviour. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smoothFactor,:</em>&nbsp;</td><td>The number of times the vertices are smoothed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addAlsoIfHeightmapEmpty,:</em>&nbsp;</td><td>Add terrain node even with empty heightmap. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created scene node. Can be null if the terrain could not be created, for example because the heightmap could not be loaded. The returned pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23"></a><!-- doxytag: member=<irr::scene::ISceneManager::addTerrainSceneNode> ref=<a23> args=<(const c8 *heightMapFileName, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 maxLOD=5, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, s32 smoothFactor=0, bool addAlsoIfHeightmapEmpty=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITerrainSceneNode* irr::scene::ISceneManager::addTerrainSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>heightMapFileName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0.0f,&nbsp;0.0f,&nbsp;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rotation</em> = <code>core::vector3df(0.0f,&nbsp;0.0f,&nbsp;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em> = <code>core::vector3df(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexColor</em> = <code>video::SColor(255,&nbsp;255,&nbsp;255,&nbsp;255)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>maxLOD</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>E_TERRAIN_PATCH_SIZE&nbsp;</td>
          <td class="mdname" nowrap> <em>patchSize</em> = <code>ETPS_17</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>smoothFactor</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>addAlsoIfHeightmapEmpty</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This node implements is a simple terrain renderer which uses a technique known as geo mip mapping for reducing the detail of triangle blocks which are far away. 
<p>
The code for the TerrainSceneNode is based on the terrain renderer by Soconne and the GeoMipMapSceneNode developed by Spintz. They made their code available for Irrlicht and allowed it to be distributed under this licence. I only modified some parts. A lot of thanks go to them.<p>
This scene node is capable of loading terrains and updating the indices at runtime to enable viewing very large terrains very quickly. It uses a CLOD (Continuous Level of Detail) algorithm which updates the indices for each patch based on a LOD (Level of Detail) which is determined based on a patch's distance from the camera.<p>
The patch size of the terrain must always be a size of 2^N+1, i.e. 8+1(9), 16+1(17), etc. The MaxLOD available is directly dependent on the patch size of the terrain. LOD 0 contains all of the indices to draw all the triangles at the max detail for a patch. As each LOD goes up by 1 the step taken, in generating indices increases by -2^LOD, so for LOD 1, the step taken is 2, for LOD 2, the step taken is 4, LOD 3 - 8, etc. The step can be no larger than the size of the patch, so having a LOD of 8, with a patch size of 17, is asking the algoritm to generate indices every 2^8 ( 256 ) vertices, which is not possible with a patch size of 17. The maximum LOD for a patch size of 17 is 2^4 ( 16 ). So, with a MaxLOD of 5, you'll have LOD 0 ( full detail ), LOD 1 ( every 2 vertices ), LOD 2 ( every 4 vertices ), LOD 3 ( every 8 vertices ) and LOD 4 ( every 16 vertices ). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heightMapFileName,:</em>&nbsp;</td><td>The name of the file on disk, to read vertex data from. This should be a gray scale bitmap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent of the scene node. Can be 0 if no parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>The absolute position of this node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation,:</em>&nbsp;</td><td>The absolute rotation of this node. ( NOT YET IMPLEMENTED ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale,:</em>&nbsp;</td><td>The scale factor for the terrain. If you're using a heightmap of size 129x129 and would like your terrain to be 12900x12900 in game units, then use a scale factor of ( core::vector ( 100.0f, 100.0f, 100.0f ). If you use a Y scaling factor of 0.0f, then your terrain will be flat. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexColor,:</em>&nbsp;</td><td>The default color of all the vertices. If no texture is associated with the scene node, then all vertices will be this color. Defaults to white. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxLOD,:</em>&nbsp;</td><td>The maximum LOD (level of detail) for the node. Only change if you know what you are doing, this might lead to strange behaviour. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patchSize,:</em>&nbsp;</td><td>patch size of the terrain. Only change if you know what you are doing, this might lead to strange behaviour. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smoothFactor,:</em>&nbsp;</td><td>The number of times the vertices are smoothed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addAlsoIfHeightmapEmpty,:</em>&nbsp;</td><td>Add terrain node even with empty heightmap. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the created scene node. Can be null if the terrain could not be created, for example because the heightmap could not be loaded. The returned pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a60"></a><!-- doxytag: member=<irr::scene::ISceneManager::addToDeletionQueue> ref=<a60> args=<(ISceneNode *node)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::scene::ISceneManager::addToDeletionQueue           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>node</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The scene node is immediatly deleted when it's secure. 
<p>
Which means when the scene node does not execute animators and things like that. This method is for example used for deleting scene nodes by their scene node animators. In most other cases, a ISceneNode::remove() call is enough, using this deletion queue is not necessary. See <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a49">ISceneManager::createDeleteAnimator()</a> for details. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node,:</em>&nbsp;</td><td>Node to detete. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member=<irr::scene::ISceneManager::addWaterSurfaceSceneNode> ref=<a12> args=<(IMesh *mesh, f32 waveHeight=2.0f, f32 waveSpeed=300.0f, f32 waveLength=10.0f, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::addWaterSurfaceSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IMesh *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>waveHeight</em> = <code>2.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>waveSpeed</em> = <code>300.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>waveLength</em> = <code>10.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>rotation</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em> = <code>core::vector3df(1.0f,&nbsp;1.0f,&nbsp;1.0f)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Looks really good when the Material type EMT_TRANSPARENT_REFLECTION is used. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>waveHeight,:</em>&nbsp;</td><td>Height of the water waves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waveSpeed,:</em>&nbsp;</td><td>Speed of the water waves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waveLength,:</em>&nbsp;</td><td>Lenght of a water wave. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mesh,:</em>&nbsp;</td><td>Pointer to the loaded static mesh to be displayed with water waves on it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent,:</em>&nbsp;</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation,:</em>&nbsp;</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale,:</em>&nbsp;</td><td>Initial scale of the scene node. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the created scene node. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a50"></a><!-- doxytag: member=<irr::scene::ISceneManager::createCollisionResponseAnimator> ref=<a50> args=<(ITriangleSelector *world, ISceneNode *sceneNode, const core::vector3df &amp;ellipsoidRadius=core::vector3df(30, 60, 30), const core::vector3df &amp;gravityPerSecond=core::vector3df(0,-10.0f, 0), const core::vector3df &amp;ellipsoidTranslation=core::vector3df(0, 0, 0), f32 slidingValue=0.0005f)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNodeAnimatorCollisionResponse* irr::scene::ISceneManager::createCollisionResponseAnimator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ITriangleSelector *&nbsp;</td>
          <td class="mdname" nowrap> <em>world</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>sceneNode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ellipsoidRadius</em> = <code>core::vector3df(30,&nbsp;60,&nbsp;30)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>gravityPerSecond</em> = <code>core::vector3df(0,-10.0f,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ellipsoidTranslation</em> = <code>core::vector3df(0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>slidingValue</em> = <code>0.0005f</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
See ISceneNodeAnimatorCollisionResponse for details. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>world,:</em>&nbsp;</td><td>Triangle selector holding all triangles of the world with which the scene node may collide. You can create a triangle selector with <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a52">ISceneManager::createTriangleSelector()</a>; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sceneNode,:</em>&nbsp;</td><td>SceneNode which should be manipulated. After you added this animator to the scene node, the scene node will not be able to move through walls and is affected by gravity. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ellipsoidRadius,:</em>&nbsp;</td><td>Radius of the ellipsoid with which collision detection and response is done. If you have got a scene node, and you are unsure about how big the radius should be, you could use the following code to determine it: <div class="fragment"><pre class="fragment">                 <span class="keyword">const</span> core::aabbox3d&lt;f32&gt;&amp; box = yourSceneNode-&gt;getBoundingBox();
                 core::vector3df radius = box.MaxEdge - box.getCenter();
</pre></div> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gravityPerSecond,:</em>&nbsp;</td><td>Sets the gravity of the environment, as an acceleration in units per second per second. If your units are equivalent to metres, then core::vector3df(0,-10.0f,0) would give an approximately realistic gravity. You can disable gravity by setting it to core::vector3df(0,0,0). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ellipsoidTranslation,:</em>&nbsp;</td><td>By default, the ellipsoid for collision detection is created around the center of the scene node, which means that the ellipsoid surrounds it completely. If this is not what you want, you may specify a translation for the ellipsoid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slidingValue,:</em>&nbsp;</td><td>DOCUMENTATION NEEDED. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the animator. Attach it to a scene node with ISceneNode::addAnimator() and the animator will cause it to do collision detection and response. If you no longer need the animator, you should call ISceneNodeAnimator::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a49"></a><!-- doxytag: member=<irr::scene::ISceneManager::createDeleteAnimator> ref=<a49> args=<(u32 timeMs)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNodeAnimator* irr::scene::ISceneManager::createDeleteAnimator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>timeMs</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeMs,:</em>&nbsp;</td><td>Time in milliseconds, after when the node will be deleted. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the animator. Attach it to a scene node with ISceneNode::addAnimator() and the animator will animate it. If you no longer need the animator, you should call ISceneNodeAnimator::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a46"></a><!-- doxytag: member=<irr::scene::ISceneManager::createFlyCircleAnimator> ref=<a46> args=<(const core::vector3df &amp;center=core::vector3df(0.f, 0.f, 0.f), f32 radius=100.f, f32 speed=0.001f, const core::vector3df &amp;direction=core::vector3df(0.f, 1.f, 0.f))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNodeAnimator* irr::scene::ISceneManager::createFlyCircleAnimator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>center</em> = <code>core::vector3df(0.f,&nbsp;0.f,&nbsp;0.f)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em> = <code>100.f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>speed</em> = <code>0.001f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>direction</em> = <code>core::vector3df(0.f,&nbsp;1.f,&nbsp;0.f)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center,:</em>&nbsp;</td><td>Center of the circle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius,:</em>&nbsp;</td><td>Radius of the circle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>speed,:</em>&nbsp;</td><td>Specifies the speed of the flight. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction,:</em>&nbsp;</td><td>Specifies the upvector used for alignment of the mesh. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The animator. Attach it to a scene node with ISceneNode::addAnimator() and the animator will animate it. If you no longer need the animator, you should call ISceneNodeAnimator::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a47"></a><!-- doxytag: member=<irr::scene::ISceneManager::createFlyStraightAnimator> ref=<a47> args=<(const core::vector3df &amp;startPoint, const core::vector3df &amp;endPoint, u32 timeForWay, bool loop=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNodeAnimator* irr::scene::ISceneManager::createFlyStraightAnimator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>startPoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>endPoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>timeForWay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>loop</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startPoint,:</em>&nbsp;</td><td>Start point of the line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endPoint,:</em>&nbsp;</td><td>End point of the line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeForWay,:</em>&nbsp;</td><td>Time in milli seconds how long the node should need to move from the start point to the end point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loop,:</em>&nbsp;</td><td>If set to false, the node stops when the end point is reached. If loop is true, the node begins again at the start. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the animator. Attach it to a scene node with ISceneNode::addAnimator() and the animator will animate it. If you no longer need the animator, you should call ISceneNodeAnimator::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a51"></a><!-- doxytag: member=<irr::scene::ISceneManager::createFollowSplineAnimator> ref=<a51> args=<(s32 startTime, const core::array&lt; core::vector3df &gt; &amp;points, f32 speed=1.0f, f32 tightness=0.5f)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNodeAnimator* irr::scene::ISceneManager::createFollowSplineAnimator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s32&nbsp;</td>
          <td class="mdname" nowrap> <em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::array&lt; core::vector3df &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>speed</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>tightness</em> = <code>0.5f</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The animator modifies the position of the attached scene node to make it follow a hermite spline. 
<p>
It uses a subset of hermite splines: either cardinal splines (tightness != 0.5) or catmull-rom-splines (tightness == 0.5). The animator moves from one control point to the next in 1/speed seconds. This code was sent in by Matthias Gall.     </td>
  </tr>
</table>
<a class="anchor" name="a55"></a><!-- doxytag: member=<irr::scene::ISceneManager::createMetaTriangleSelector> ref=<a55> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IMetaTriangleSelector* irr::scene::ISceneManager::createMetaTriangleSelector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A meta triangle selector is nothing more than a collection of one or more triangle selectors providing together the interface of one triangle selector. 
<p>
In this way, collision tests can be done with different triangle soups in one pass. <dl compact><dt><b>Returns:</b></dt><dd>Returns the selector, or null if not successful. If you no longer need the selector, you should call ITriangleSelector::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a75"></a><!-- doxytag: member=<irr::scene::ISceneManager::createNewSceneManager> ref=<a75> args=<(bool cloneContent=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html">ISceneManager</a>* irr::scene::ISceneManager::createNewSceneManager           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cloneContent</em> = <code>false</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This can be used to easily draw and/or store two independent scenes at the same time. 
<p>
The mesh cache will be shared between all existing scene managers, which means if you load a mesh in the original scene manager using for example <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">getMesh()</a>, the mesh will be available in all other scene managers too, without loading. The original/main scene manager will still be there and accessible via IrrlichtDevice::getSceneManager(). If you need input event in this new scene manager, for example for FPS cameras, you'll need to forward input to this manually: Just implement an IEventReceiver and call yourNewSceneManager-&gt;<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a61">postEventFromUser()</a>, and return true so that the original scene manager doesn't get the event. Otherwise, all input will go to the main scene manager automatically. If you no longer need the new scene manager, you should call ISceneManager::drop(). See IReferenceCounted::drop() for more information.     </td>
  </tr>
</table>
<a class="anchor" name="a54"></a><!-- doxytag: member=<irr::scene::ISceneManager::createOctTreeTriangleSelector> ref=<a54> args=<(IMesh *mesh, ISceneNode *node, s32 minimalPolysPerNode=32)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITriangleSelector* irr::scene::ISceneManager::createOctTreeTriangleSelector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IMesh *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>minimalPolysPerNode</em> = <code>32</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Triangle selectors can be used for doing collision detection. 
<p>
This triangle selector is optimized for huge amounts of triangle, it organizes them in an octtree. Please note that the created triangle selector is not automaticly attached to the scene node. You will have to call ISceneNode::setTriangleSelector() for this. To create and attach a triangle selector is done like this: <div class="fragment"><pre class="fragment">                 ITriangleSelector* s = sceneManager-&gt;createOctTreeTriangleSelector(yourMesh,
                                yourSceneNode);
                 yourSceneNode-&gt;setTriangleSelector(s);
                 s-&gt;drop();
</pre></div> For more informations and examples on this, take a look at the collision tutorial in the SDK. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mesh,:</em>&nbsp;</td><td>Mesh of which the triangles are taken. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node,:</em>&nbsp;</td><td>Scene node of which visibility and transformation is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimalPolysPerNode,:</em>&nbsp;</td><td>Specifies the minimal polygons contained a octree node. If a node gets less polys the this value, it will not be splitted into smaller nodes. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the selector, or null if not successful. If you no longer need the selector, you should call ITriangleSelector::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a45"></a><!-- doxytag: member=<irr::scene::ISceneManager::createRotationAnimator> ref=<a45> args=<(const core::vector3df &amp;rotationPerSecond)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNodeAnimator* irr::scene::ISceneManager::createRotationAnimator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::vector3df &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rotationPerSecond</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rotationPerSecond,:</em>&nbsp;</td><td>Specifies the speed of the animation </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The animator. Attach it to a scene node with ISceneNode::addAnimator() and the animator will animate it. If you no longer need the animator, you should call ISceneNodeAnimator::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a56"></a><!-- doxytag: member=<irr::scene::ISceneManager::createTerrainTriangleSelector> ref=<a56> args=<(ITerrainSceneNode *node, s32 LOD=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITriangleSelector* irr::scene::ISceneManager::createTerrainTriangleSelector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ITerrainSceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>LOD</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node,:</em>&nbsp;</td><td>Pointer to the created terrain scene node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LOD,:</em>&nbsp;</td><td>Level of detail, 0 for highest detail. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a48"></a><!-- doxytag: member=<irr::scene::ISceneManager::createTextureAnimator> ref=<a48> args=<(const core::array&lt; video::ITexture * &gt; &amp;textures, s32 timePerFrame, bool loop=true)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNodeAnimator* irr::scene::ISceneManager::createTextureAnimator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::array&lt; video::ITexture * &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>textures</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>timePerFrame</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>loop</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>textures,:</em>&nbsp;</td><td>List of textures to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timePerFrame,:</em>&nbsp;</td><td>Time in milliseconds, how long any texture in the list should be visible. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loop,:</em>&nbsp;</td><td>If set to to false, the last texture remains set, and the animation stops. If set to true, the animation restarts with the first texture. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the animator. Attach it to a scene node with ISceneNode::addAnimator() and the animator will animate it. If you no longer need the animator, you should call ISceneNodeAnimator::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a52"></a><!-- doxytag: member=<irr::scene::ISceneManager::createTriangleSelector> ref=<a52> args=<(IMesh *mesh, ISceneNode *node)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITriangleSelector* irr::scene::ISceneManager::createTriangleSelector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IMesh *&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>node</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Triangle selectors can be used for doing collision detection. 
<p>
Don't use this selector for a huge amount of triangles like in Quake3 maps. Instead, use for example <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a54">ISceneManager::createOctTreeTriangleSelector()</a>. Please note that the created triangle selector is not automaticly attached to the scene node. You will have to call ISceneNode::setTriangleSelector() for this. To create and attach a triangle selector is done like this: <div class="fragment"><pre class="fragment">                 ITriangleSelector* s = sceneManager-&gt;createTriangleSelector(yourMesh,
                                yourSceneNode);
                 yourSceneNode-&gt;setTriangleSelector(s);
                 s-&gt;drop();
</pre></div> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mesh,:</em>&nbsp;</td><td>Mesh of which the triangles are taken. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node,:</em>&nbsp;</td><td>Scene node of which visibility and transformation is used. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the selector, or null if not successful. If you no longer need the selector, you should call ITriangleSelector::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a53"></a><!-- doxytag: member=<irr::scene::ISceneManager::createTriangleSelectorFromBoundingBox> ref=<a53> args=<(ISceneNode *node)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITriangleSelector* irr::scene::ISceneManager::createTriangleSelectorFromBoundingBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>node</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Triangle selectors can be used for doing collision detection. 
<p>
Every time when triangles are queried, the triangle selector gets the bounding box of the scene node, an creates new triangles. In this way, it works good with animated scene nodes. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node,:</em>&nbsp;</td><td>Scene node of which the bounding box, visibility and transformation is used. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the selector, or null if not successful. If you no longer need the selector, you should call ITriangleSelector::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a44"></a><!-- doxytag: member=<irr::scene::ISceneManager::drawAll> ref=<a44> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::scene::ISceneManager::drawAll           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This can only be invoked between IVideoDriver::beginScene() and IVideoDriver::endScene(). 
<p>
Please note that the scene is not only drawn when calling this, but also animated by existing scene node animators, culling of scene nodes is done, etc.     </td>
  </tr>
</table>
<a class="anchor" name="a39"></a><!-- doxytag: member=<irr::scene::ISceneManager::getActiveCamera> ref=<a39> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ICameraSceneNode* irr::scene::ISceneManager::getActiveCamera           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>The active camera is returned. Note that this can be NULL, if there was no camera created yet. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6"></a><!-- doxytag: member=<irr::scene::ISceneManager::getGUIEnvironment> ref=<a6> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual gui::IGUIEnvironment* irr::scene::ISceneManager::getGUIEnvironment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the GUIEnvironment This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5"></a><!-- doxytag: member=<irr::scene::ISceneManager::getMaterialSystem> ref=<a5> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classirr_1_1video_1_1_i_material_system.html">video::IMaterialSystem</a>* irr::scene::ISceneManager::getMaterialSystem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the Material System. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the Material System. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>IMaterialSystem.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2"></a><!-- doxytag: member=<irr::scene::ISceneManager::getMesh> ref=<a2> args=<(io::IReadFile *file)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IAnimatedMesh* irr::scene::ISceneManager::getMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">io::IReadFile *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>file</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Works just as getMesh(const char* filename). 
<p>
If you want to remove a loaded mesh from the cache again, use removeMesh(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>File handle of the mesh to load. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if failed and pointer to the mesh if successful. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1"></a><!-- doxytag: member=<irr::scene::ISceneManager::getMesh> ref=<a1> args=<(const c8 *filename)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IAnimatedMesh* irr::scene::ISceneManager::getMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>filename</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If you want to remove a loaded mesh from the cache again, use removeMesh(). 
<p>
Currently there are the following mesh formats supported: <table border="1" cellpadding="2" cellspacing="0">
<tr>
<td>Format </td><td>Description  </td></tr>
<tr>
<td>3D Studio (.3ds) </td><td>Loader for 3D-Studio files which lots of 3D packages are able to export. Only static meshes are currently supported by this importer.   </td></tr>
<tr>
<td>Bliz Basic B3D (.b3d) </td><td>Loader for blitz basic files, developed by Mark Sibly, also supports animations.  </td></tr>
<tr>
<td>Cartography shop 4 (.csm) </td><td>Cartography Shop is a modeling program for creating architecture and calculating lighting. Irrlicht can directly import .csm files thanks to the IrrCSM library created by Saurav Mohapatra which is now integrated directly in Irrlicht. If you are using this loader, please note that you'll have to set the path of the textures before loading .csm files. You can do this using SceneManager-&gt;<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a63">getParameters()</a>-&gt;setParameter(scene::CSM_TEXTURE_PATH, "path/to/your/textures");  </td></tr>
<tr>
<td>COLLADA (.dae, .xml) </td><td>COLLADA is an open Digital Asset Exchange Schema for the interactive 3D industry. There are exporters and importers for this format available for most of the big 3d packagesat <a href="http://collada.org.">http://collada.org.</a> Irrlicht can import COLLADA files by using the <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a1">ISceneManager::getMesh()</a> method. COLLADA files need not contain only one single mesh but multiple meshes and a whole scene setup with lights, cameras and mesh instances, this loader can set up a scene as described by the COLLADA file instead of loading and returning one single mesh. By default, this loader behaves like the other loaders and does not create instances, but it can be switched into this mode by using SceneManager-&gt;<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a63">getParameters()</a>-&gt;setParameter(COLLADA_CREATE_SCENE_INSTANCES, true); Created scene nodes will be named as the names of the nodes in the COLLADA file. The returned mesh is just a dummy object in this mode. Meshes included in the scene will be added into the scene manager with the following naming scheme: path/to/file/file.dea::meshname. The loading of such meshes is logged. Currently, this loader is able to create meshes (made of only polygons), lights, and cameras. Materials and animations are currently not supported but this will change with future releases.   </td></tr>
<tr>
<td>Delgine DeleD (.dmf) </td><td>DeleD (delgine.com) is a 3D editor and level-editor combined into one and is specifically designed for 3D game-development. With this loader, it is possible to directly load all geometry is as well as textures and lightmaps from .dmf files. To set texture and material paths, see scene::DMF_USE_MATERIALS_DIRS and scene::DMF_TEXTURE_PATH. It is also possible to flip the alpha texture by setting scene::DMF_FLIP_ALPHA_TEXTURES to true and to set the material transparent reference value by setting scene::DMF_ALPHA_CHANNEL_REF to a float between 0 and 1. The loader is based on Salvatore Russo's .dmf loader, I just changed some parts of it. Thanks to Salvatore for his work and for allowing me to use his code in Irrlicht and put it under Irrlicht's license. For newer and more enchanced versions of the loader, take a look at delgine.com.  </td></tr>
<tr>
<td>DirectX (.x) </td><td>Platform independent importer (so not D3D-only) for .x files. Most 3D packages can export these natively and there are several tools for them available, e.g. the Maya exporter included in the DX SDK. .x files can include skeletal animations and Irrlicht is able to play and display them. Currently, Irrlicht only supports uncompressed .x files.  </td></tr>
<tr>
<td>Maya (.obj) </td><td>Most 3D software can create .obj files which contain static geometry without material data. The material files .mtl are also supported. This importer for Irrlicht can load them directly.   </td></tr>
<tr>
<td>Milkshape (.ms3d) </td><td>.MS3D files contain models and sometimes skeletal animations from the Milkshape 3D modeling and animation software. This importer for Irrlicht can display and/or animate these files.   </td></tr>
<tr>
<td>My3D (.my3d) </td><td>.my3D is a flexible 3D file format. The My3DTools contains plug-ins to export .my3D files from several 3D packages. With this built-in importer, Irrlicht can read and display those files directly. This loader was written by Zhuck Dimitry who also created the whole My3DTools package. If you are using this loader, please note that you can set the path of the textures before loading .my3d files. You can do this using SceneManager-&gt;<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a63">getParameters()</a>-&gt;setParameter(scene::MY3D_TEXTURE_PATH, "path/to/your/textures");  </td></tr>
<tr>
<td>OCT (.oct) </td><td>The oct file format contains 3D geometry and lightmaps and can be loaded directly by Irrlicht. OCT files<br>
 can be created by FSRad, Paul Nette's radiosity processor or exported from Blender using OCTTools which can be found in the exporters/OCTTools directory of the SDK. Thanks to Murphy McCauley for creating all this.  </td></tr>
<tr>
<td>OGRE Meshes (.mesh) </td><td>Ogre .mesh files contain 3D data for the OGRE 3D engine. Irrlicht can read and display them directly with this importer. To define materials for the mesh, copy a .material file named like the corresponding .mesh file where the .mesh file is. (For example ogrehead.material for ogrehead.mesh). Thanks to Christian Stehno who wrote and contributed this loader.  </td></tr>
<tr>
<td>Pulsar LMTools (.lmts) </td><td>LMTools is a set of tools (Windows &amp; Linux) for creating lightmaps. Irrlicht can directly read .lmts files thanks to<br>
 the importer created by Jonas Petersen. If you are using this loader, please note that you can set the path of the textures before loading .lmts files. You can do this using SceneManager-&gt;<a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a63">getParameters()</a>-&gt;setParameter(scene::LMTS_TEXTURE_PATH, "path/to/your/textures"); Notes for<br>
 this version of the loader:<br>
<ul>
<li>It does not recognise/support user data in the *.lmts files.<br>
</li><li>The TGAs generated by LMTools don't work in Irrlicht for some reason (the textures are upside down). Opening and resaving them in a graphics app will solve the problem.  </li></ul>
</td></tr>
<tr>
<td>Quake 3 levels (.bsp) </td><td>Quake 3 is a popular game by IDSoftware, and .pk3 files contain .bsp files and textures/lightmaps describing huge prelighted levels. Irrlicht can read .pk3 and .bsp files directly and thus render Quake 3 levels directly. Written by Nikolaus Gebhardt enhanced by Dean P. Macri with the curved surfaces feature.  </td></tr>
<tr>
<td>Quake 2 models (.md2) </td><td>Quake 2 models are characters with morph target animation. Irrlicht can read, display and animate them directly with this importer.   </td></tr>
</table>
<p>
To load and display a mesh quickly, just do this: <div class="fragment"><pre class="fragment"> SceneManager-&gt;addAnimatedMeshSceneNode(
                SceneManager-&gt;getMesh(<span class="stringliteral">"yourmesh.3ds"</span>));
</pre></div> If you would like to implement and add your own file format loader to Irrlicht, see <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a57">addExternalMeshLoader()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename,:</em>&nbsp;</td><td>Filename of the mesh to load. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns NULL if failed and the pointer to the mesh if successful. This pointer should not be dropped. See IReferenceCounted::drop() for more information.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a63"></a><!-- doxytag: member=<irr::scene::ISceneManager::getParameters> ref=<a63> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual io::IAttributes* irr::scene::ISceneManager::getParameters           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
String parameters can be used by plugins and mesh loaders. 
<p>
For example the CMS and LMTS loader want a parameter named 'CSM_TexturePath' and 'LMTS_TexturePath' set to the path were attached textures can be found. See CSM_TEXTURE_PATH, LMTS_TEXTURE_PATH, MY3D_TEXTURE_PATH, COLLADA_CREATE_SCENE_INSTANCES, DMF_TEXTURE_PATH and DMF_USE_MATERIALS_DIRS     </td>
  </tr>
</table>
<a class="anchor" name="a34"></a><!-- doxytag: member=<irr::scene::ISceneManager::getRootSceneNode> ref=<a34> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::getRootSceneNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is the scene node which is parent of all scene nodes. 
<p>
The root scene node is a special scene node which only exists to manage all scene nodes. It will not be rendered and cannot be removed from the scene. <dl compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the root scene node. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneNodeFromId> ref=<a35> args=<(s32 id, ISceneNode *start=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::getSceneNodeFromId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s32&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id,:</em>&nbsp;</td><td>The id to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start,:</em>&nbsp;</td><td>Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the first scene node with this id, and null if no scene node could be found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneNodeFromName> ref=<a36> args=<(const c8 *name, ISceneNode *start=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::getSceneNodeFromName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name,:</em>&nbsp;</td><td>The name to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start,:</em>&nbsp;</td><td>Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the first scene node with this id, and null if no scene node could be found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a37"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneNodeFromType> ref=<a37> args=<(scene::ESCENE_NODE_TYPE type, ISceneNode *start=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ISceneNode* irr::scene::ISceneManager::getSceneNodeFromType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">scene::ESCENE_NODE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type,:</em>&nbsp;</td><td>The type to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start,:</em>&nbsp;</td><td>Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the first scene node with this type, and null if no scene node could be found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a64"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneNodeRenderPass> ref=<a64> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="namespaceirr_1_1scene.html#a8">E_SCENE_NODE_RENDER_PASS</a> irr::scene::ISceneManager::getSceneNodeRenderPass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
All scene nodes are being rendered in a specific order. 
<p>
First lights, cameras, sky boxes, solid geometry, and then transparent stuff. During the rendering process, scene nodes may want to know what the scene manager is rendering currently, because for example they registered for rendering twice, once for transparent geometry and once for solid. When knowing what rendering pass currently is active they can render the correct part of their geometry.     </td>
  </tr>
</table>
<a class="anchor" name="a38"></a><!-- doxytag: member=<irr::scene::ISceneManager::getSceneNodesFromType> ref=<a38> args=<(ESCENE_NODE_TYPE type, core::array&lt; scene::ISceneNode * &gt; &amp;outNodes, ISceneNode *start=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::scene::ISceneManager::getSceneNodesFromType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ESCENE_NODE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>core::array&lt; scene::ISceneNode * &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outNodes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type,:</em>&nbsp;</td><td>Type of scene node to find (ESNT_ANY will return all child nodes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outNodes,:</em>&nbsp;</td><td>array to be filled with results. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start,:</em>&nbsp;</td><td>Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4"></a><!-- doxytag: member=<irr::scene::ISceneManager::getVideoDriver> ref=<a4> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classirr_1_1video_1_1_i_video_driver.html">video::IVideoDriver</a>* irr::scene::ISceneManager::getVideoDriver           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Returns pointer to the video Driver. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a79"></a><!-- doxytag: member=<irr::scene::ISceneManager::loadScene> ref=<a79> args=<(io::IReadFile *file, ISceneUserDataSerializer *userDataSerializer=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::scene::ISceneManager::loadScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">io::IReadFile *&nbsp;</td>
          <td class="mdname" nowrap> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneUserDataSerializer *&nbsp;</td>
          <td class="mdname" nowrap> <em>userDataSerializer</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The scene is usually load from an .irr file, an xml based format. 
<p>
.irr files can Be edited with the Irrlicht Engine Editor, irrEdit (<a href="http://irredit.irrlicht3d.org">http://irredit.irrlicht3d.org</a>) or saved directly by the engine using <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a76">ISceneManager::saveScene()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file,:</em>&nbsp;</td><td>File where the scene is going to be saved into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userDataSerializer,:</em>&nbsp;</td><td>If you want to load user data possibily saved in that file for some scene nodes in the file, implement the ISceneUserDataSerializer interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true if successful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a78"></a><!-- doxytag: member=<irr::scene::ISceneManager::loadScene> ref=<a78> args=<(const c8 *filename, ISceneUserDataSerializer *userDataSerializer=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::scene::ISceneManager::loadScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneUserDataSerializer *&nbsp;</td>
          <td class="mdname" nowrap> <em>userDataSerializer</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The scene is usually load from an .irr file, an xml based format. 
<p>
.irr files can Be edited with the Irrlicht Engine Editor, irrEdit (<a href="http://irredit.irrlicht3d.org">http://irredit.irrlicht3d.org</a>) or saved directly by the engine using <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a76">ISceneManager::saveScene()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename,:</em>&nbsp;</td><td>Name of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userDataSerializer,:</em>&nbsp;</td><td>If you want to load user data possibily saved in that file for some scene nodes in the file, implement the ISceneUserDataSerializer interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true if successful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a43"></a><!-- doxytag: member=<irr::scene::ISceneManager::registerNodeForRendering> ref=<a43> args=<(ISceneNode *node, E_SCENE_NODE_RENDER_PASS pass=ESNRP_AUTOMATIC)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual u32 irr::scene::ISceneManager::registerNodeForRendering           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ISceneNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="namespaceirr_1_1scene.html#a8">E_SCENE_NODE_RENDER_PASS</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pass</em> = <code>ESNRP_AUTOMATIC</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method should only be used by SceneNodes when they get a ISceneNode::OnRegisterSceneNode() call. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node,:</em>&nbsp;</td><td>Node to register for drawing. Usually scene nodes would set 'this' as parameter here because they want to be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pass,:</em>&nbsp;</td><td>Specifies when the node wants to be drawn in relation to the other nodes. For example, if the node is a shadow, it usually wants to be drawn after all other nodes and will use ESNRP_SHADOW for this. See <a class="el" href="namespaceirr_1_1scene.html#a8">scene::E_SCENE_NODE_RENDER_PASS</a> for details. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>scene will be rendered ( passed culling ) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a77"></a><!-- doxytag: member=<irr::scene::ISceneManager::saveScene> ref=<a77> args=<(io::IWriteFile *file, ISceneUserDataSerializer *userDataSerializer=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::scene::ISceneManager::saveScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">io::IWriteFile *&nbsp;</td>
          <td class="mdname" nowrap> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneUserDataSerializer *&nbsp;</td>
          <td class="mdname" nowrap> <em>userDataSerializer</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scene nodes with the option isDebugObject set to true are not being saved. 
<p>
The scene is usually written to an .irr file, an xml based format. .irr files can Be edited with the Irrlicht Engine Editor, irrEdit (<a href="http://irredit.irrlicht3d.org">http://irredit.irrlicht3d.org</a>). To load .irr files again, see <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a78">ISceneManager::loadScene()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file,:</em>&nbsp;</td><td>File where the scene is saved into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userDataSerializer,:</em>&nbsp;</td><td>If you want to save some user data for every scene node into the file, implement the ISceneUserDataSerializer interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true if successful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a76"></a><!-- doxytag: member=<irr::scene::ISceneManager::saveScene> ref=<a76> args=<(const c8 *filename, ISceneUserDataSerializer *userDataSerializer=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::scene::ISceneManager::saveScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ISceneUserDataSerializer *&nbsp;</td>
          <td class="mdname" nowrap> <em>userDataSerializer</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scene nodes with the option isDebugObject set to true are not being saved. 
<p>
The scene is usually written to an .irr file, an xml based format. .irr files can Be edited with the Irrlicht Engine Editor, irrEdit (<a href="http://irredit.irrlicht3d.org">http://irredit.irrlicht3d.org</a>). To load .irr files again, see <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a78">ISceneManager::loadScene()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename,:</em>&nbsp;</td><td>Name of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userDataSerializer,:</em>&nbsp;</td><td>If you want to save some user data for every scene node into the file, implement the ISceneUserDataSerializer interface and provide it as parameter here. Otherwise, simply specify 0 as this parameter. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true if successful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a40"></a><!-- doxytag: member=<irr::scene::ISceneManager::setActiveCamera> ref=<a40> args=<(ICameraSceneNode *camera)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::scene::ISceneManager::setActiveCamera           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ICameraSceneNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>camera</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The previous active camera will be deactivated. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>camera,:</em>&nbsp;</td><td>The new camera which should be active. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_i_scene_manager_8h-source.html">ISceneManager.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 19 18:54:21 2009 for Material System by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.3 </small></address>
</body>
</html>
