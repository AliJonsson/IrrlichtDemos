<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Material System: irr::video::IVideoDriver Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="namespaceirr.html">irr</a>::<a class="el" href="namespaceirr_1_1video.html">video</a>::<a class="el" href="classirr_1_1video_1_1_i_video_driver.html">IVideoDriver</a></div>
<h1>irr::video::IVideoDriver Class Reference</h1><!-- doxytag: class=<irr::video::IVideoDriver> -->This interface is one of the most important interfaces of the Irrlicht Engine: All rendering and texture manipulation is done with this interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_i_video_driver_8h-source.html">IVideoDriver.h</a>&gt;</code>
<p>
<a href="classirr_1_1video_1_1_i_video_driver-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a0">beginScene</a> (bool backBuffer=true, bool zBuffer=true, SColor color=SColor(255, 0, 0, 0), void *windowId=0, core::rect&lt; s32 &gt; *sourceRect=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method can clear the back- and the z-buffer.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a1">endScene</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applications must call this method after performing any rendering.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a2">queryFeature</a> (E_VIDEO_DRIVER_FEATURE feature) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if a feature is available.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a3">disableFeature</a> (E_VIDEO_DRIVER_FEATURE feature, bool flag=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can also be used to enable the features again.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a4">checkDriverReset</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For d3d devices you will need to recreate the RTTs if the driver was reset.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a5">setTransform</a> (<a class="el" href="namespaceirr_1_1video.html#a36">E_TRANSFORMATION_STATE</a> state, const core::matrix4 &amp;mat)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const core::matrix4 &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a6">getTransform</a> (<a class="el" href="namespaceirr_1_1video.html#a36">E_TRANSFORMATION_STATE</a> state) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a7">setMaterial</a> (const <a class="el" href="classirr_1_1video_1_1_s_material.html">SMaterial</a> &amp;material)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All 3d drawing functions will draw geometry using this material thereafter.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a8">getTexture</a> (const c8 *filename)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads the texture from disk if it is not already loaded and generates mipmap levels if desired.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a9">getTexture</a> (const core::stringc &amp;filename)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads the texture from disk if it is not already loaded and generates mipmap levels if desired.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a10">getTexture</a> (io::IReadFile *file)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads the texture from disk if it is not already loaded and generates mipmap levels if desired.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a11">getTextureByIndex</a> (u32 index)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a12">getTextureCount</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a13">renameTexture</a> (ITexture *texture, const c8 *newName)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a14">addTexture</a> (const core::dimension2d&lt; s32 &gt; &amp;size, const c8 *name, ECOLOR_FORMAT format=ECF_A8R8G8B8)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a15">addTexture</a> (const c8 *name, IImage *image)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a16">addRenderTargetTexture</a> (const core::dimension2d&lt; s32 &gt; &amp;size, const c8 *name=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a17">createRenderTargetTexture</a> (const core::dimension2d&lt; s32 &gt; &amp;size, const c8 *name=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a18">removeTexture</a> (ITexture *texture)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method can free a lot of memory! Please note that after calling this, the pointer to the ITexture may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a19">removeAllTextures</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method can free a lot of memory! Please note that after calling this, the pointer to the ITexture may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a20"></a><!-- doxytag: member=<irr::video::IVideoDriver::removeHardwareBuffer> ref=<a20> args=<(const scene::IMeshBuffer *mb)=0> -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a20">removeHardwareBuffer</a> (const scene::IMeshBuffer *mb)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove hardware buffer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a21"></a><!-- doxytag: member=<irr::video::IVideoDriver::removeAllHardwareBuffers> ref=<a21> args=<()=0> -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a21">removeAllHardwareBuffers</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all hardware buffers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a22">makeColorKeyTexture</a> (video::ITexture *texture, video::SColor color) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This makes the texture transparent at the regions where this color key can be found when using for example draw2DImage with useAlphachannel==true.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a23">makeColorKeyTexture</a> (video::ITexture *texture, core::position2d&lt; s32 &gt; colorKeyPixelPos) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This makes the texture transparent at the regions where this color key can be found when using for example draw2DImage with useAlphachannel==true.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a24">makeNormalMapTexture</a> (video::ITexture *texture, f32 amplitude=1.0f) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the target texture has 32 bit, the height value is stored in the alpha component of the texture as addition.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a25">setRenderTarget</a> (video::ITexture *texture, bool clearBackBuffer=true, bool clearZBuffer=true, SColor color=video::SColor(0, 0, 0, 0))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will only work if the driver supports the EVDF_RENDER_TO_TARGET feature, which can be queried with <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a2">queryFeature()</a>.  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a26">setViewPort</a> (const core::rect&lt; s32 &gt; &amp;area)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Every rendering operation is done into this new area.  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const core::rect&lt;<br>
 s32 &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a27">getViewPort</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a28">drawVertexPrimitiveList</a> (const void *vertices, u32 vertexCount, const void *indexList, u32 primCount, E_VERTEX_TYPE vType, scene::E_PRIMITIVE_TYPE pType, E_INDEX_TYPE iType)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536.  <a href="#a28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a29">drawIndexedTriangleList</a> (const S3DVertex *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536.  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a30">drawIndexedTriangleList</a> (const S3DVertex2TCoords *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a31">drawIndexedTriangleList</a> (const S3DVertexTangents *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536.  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a32">drawIndexedTriangleFan</a> (const S3DVertex *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536.  <a href="#a32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a33">drawIndexedTriangleFan</a> (const S3DVertex2TCoords *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536.  <a href="#a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a34">draw3DLine</a> (const core::vector3df &amp;start, const core::vector3df &amp;end, SColor color=SColor(255, 255, 255, 255))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For some implementations, this method simply calls drawIndexedTriangles for some triangles.  <a href="#a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a35">draw3DTriangle</a> (const core::triangle3df &amp;triangle, SColor color=SColor(255, 255, 255, 255))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method calls drawIndexedTriangles for some triangles.  <a href="#a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a36">draw3DBox</a> (const core::aabbox3d&lt; f32 &gt; &amp;box, SColor color=SColor(255, 255, 255, 255))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method simply calls draw3DLine for the edges of the box.  <a href="#a36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a37">draw2DImage</a> (const video::ITexture *texture, const core::position2d&lt; s32 &gt; &amp;destPos)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a38">draw2DImage</a> (const video::ITexture *texture, const core::position2d&lt; s32 &gt; &amp;destPos, const core::rect&lt; s32 &gt; &amp;sourceRect, const core::rect&lt; s32 &gt; *clipRect=0, SColor color=SColor(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(if color is other than Color(255,255,255,255)) and the alpha channel of the texture.  <a href="#a38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a39">draw2DImage</a> (const video::ITexture *texture, const core::position2d&lt; s32 &gt; &amp;pos, const core::array&lt; core::rect&lt; s32 &gt; &gt; &amp;sourceRects, const core::array&lt; s32 &gt; &amp;indices, s32 kerningWidth=0, const core::rect&lt; s32 &gt; *clipRect=0, SColor color=SColor(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The images are drawn beginning at pos and concatenated in one line.  <a href="#a39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a40">draw2DImage</a> (const video::ITexture *texture, const core::rect&lt; s32 &gt; &amp;destRect, const core::rect&lt; s32 &gt; &amp;sourceRect, const core::rect&lt; s32 &gt; *clipRect=0, const video::SColor *const colors=0, bool useAlphaChannelOfTexture=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suggested and first implemented by zola.  <a href="#a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a41">draw2DRectangle</a> (SColor color, const core::rect&lt; s32 &gt; &amp;pos, const core::rect&lt; s32 &gt; *clip=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a42">draw2DRectangle</a> (const core::rect&lt; s32 &gt; &amp;pos, SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown, const core::rect&lt; s32 &gt; *clip=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a43">draw2DLine</a> (const core::position2d&lt; s32 &gt; &amp;start, const core::position2d&lt; s32 &gt; &amp;end, SColor color=SColor(255, 255, 255, 255))=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a44">drawPixel</a> (u32 x, u32 y, const SColor &amp;color)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a45">draw2DPolygon</a> (core::position2d&lt; s32 &gt; center, f32 radius, video::SColor color=SColor(100, 255, 255, 255), s32 vertexCount=10)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method can be used to draw circles, but also triangles, tetragons, pentagons, hexagons, heptagons, octagons, enneagons, decagons, hendecagons, dodecagon, triskaidecagons, etc.  <a href="#a45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a46">drawStencilShadowVolume</a> (const core::vector3df *triangles, s32 count, bool zfail=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To draw a stencil shadow, do this: First, draw all geometry.  <a href="#a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a47">drawStencilShadow</a> (bool clearStencilBuffer=false, video::SColor leftUpEdge=video::SColor(255, 0, 0, 0), video::SColor rightUpEdge=video::SColor(255, 0, 0, 0), video::SColor leftDownEdge=video::SColor(255, 0, 0, 0), video::SColor rightDownEdge=video::SColor(255, 0, 0, 0))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">After the shadow volume has been drawn into the stencil buffer using <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a46">IVideoDriver::drawStencilShadowVolume()</a>, use this to draw the color of the shadow.  <a href="#a47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a48">drawMeshBuffer</a> (const scene::IMeshBuffer *mb)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a49">setFog</a> (SColor color=SColor(0, 255, 255, 255), bool linearFog=true, f32 start=50.0f, f32 end=100.0f, f32 density=0.01f, bool pixelFog=false, bool rangeFog=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These are global values attached to each 3d object rendered, which has the fog flag enabled in its material.  <a href="#a49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ECOLOR_FORMAT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a50">getColorFormat</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const core::dimension2d&lt;<br>
 s32 &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a51">getScreenSize</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const core::dimension2d&lt;<br>
 s32 &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a52">getCurrentRenderTargetSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method will return the screen size if the driver doesn't support render to texture, or if the current render target is the screen.  <a href="#a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual s32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a53">getFPS</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This value is updated approximately every 1.5 seconds and is only intended to provide a rough guide to the average frame rate.  <a href="#a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a54">getPrimitiveCountDrawn</a> (u32 mode=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Together with <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a53">getFPS()</a> very useful method for statistics.  <a href="#a54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a55"></a><!-- doxytag: member=<irr::video::IVideoDriver::deleteAllDynamicLights> ref=<a55> args=<()=0> -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a55">deleteAllDynamicLights</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes all dynamic lights which were previously added with <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a56">addDynamicLight()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a56">addDynamicLight</a> (const SLight &amp;light)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a57">getMaximalDynamicLightAmount</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a58">getDynamicLightCount</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const SLight &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a59">getDynamicLight</a> (u32 idx) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const wchar_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a60">getName</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a61">addExternalImageLoader</a> (IImageLoader *loader)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is useful if the Irrlicht Engine should be able to load textures of currently unsupported file formats (e.g.  <a href="#a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a62">addExternalImageWriter</a> (IImageWriter *writer)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is useful if the Irrlicht Engine should be able to write textures of currently unsupported file formats (e.g .gif).  <a href="#a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a63">getMaximalPrimitiveCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(mostly vertices) which the device is able to render with one drawIndexedTriangleList call.  <a href="#a63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a64">setTextureCreationFlag</a> (E_TEXTURE_CREATION_FLAG flag, bool enabled)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These flags define how textures should be created.  <a href="#a64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a65">getTextureCreationFlag</a> (E_TEXTURE_CREATION_FLAG flag) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">You can change this value using setTextureCreationMode().  <a href="#a65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IImage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a66">createImageFromFile</a> (const c8 *filename)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">No hardware texture will be created for this image.  <a href="#a66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IImage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a67">createImageFromFile</a> (io::IReadFile *file)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">No hardware texture will be created for this image.  <a href="#a67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a68">writeImageToFile</a> (IImage *image, const c8 *filename, u32 param=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requires that there is a suitable image writer registered for writing the image.  <a href="#a68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IImage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a69">createImageFromData</a> (ECOLOR_FORMAT format, const core::dimension2d&lt; s32 &gt; &amp;size, void *data, bool ownForeignMemory=false, bool deleteMemory=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">No hardware texture will be created for this image.  <a href="#a69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IImage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a70">createImage</a> (ECOLOR_FORMAT format, const core::dimension2d&lt; s32 &gt; &amp;size)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IImage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a71">createImage</a> (ECOLOR_FORMAT format, IImage *imageToCopy)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IImage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a72">createImage</a> (IImage *imageToCopy, const core::position2d&lt; s32 &gt; &amp;pos, const core::dimension2d&lt; s32 &gt; &amp;size)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a73">OnResize</a> (const core::dimension2d&lt; s32 &gt; &amp;size)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to notify the driver that the window was resized.  <a href="#a73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual s32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a74">addMaterialRenderer</a> (IMaterialRenderer *renderer, const c8 *name=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this method to extend the VideoDriver with new material types.  <a href="#a74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IMaterialRenderer *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a75">getMaterialRenderer</a> (u32 idx)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a76">getMaterialRendererCount</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const c8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a77">getMaterialRendererName</a> (u32 idx) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This string can, e.g.  <a href="#a77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual s32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a78">findMaterialRendererId</a> (const c8 *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the id of a the material renderer with the name <code>name</code>.  <a href="#a78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a79">setMaterialRendererName</a> (s32 idx, const c8 *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Will have no effect on built-in material renderers.  <a href="#a79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual io::IAttributes *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a80">createAttributesFromMaterial</a> (const <a class="el" href="classirr_1_1video_1_1_s_material.html">video::SMaterial</a> &amp;material)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is useful for serialization and more.  <a href="#a80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a81">fillMaterialStructureFromAttributes</a> (<a class="el" href="classirr_1_1video_1_1_s_material.html">video::SMaterial</a> &amp;outMaterial, io::IAttributes *attributes)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Please note that for setting material types of the material, the video driver will need to query the material renderers for their names, so all non built-in materials must have been created before calling this method.  <a href="#a81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const SExposedVideoData &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a82">getExposedVideoData</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method should only be used if the engine should be extended without having to modify the source of the engine.  <a href="#a82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual E_DRIVER_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a83">getDriverType</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1_i_material_system.html">IMaterialSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a84">getMaterialSystem</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Material System.  <a href="#a84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IGPUProgrammingServices *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a85">getGPUProgrammingServices</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a86"></a><!-- doxytag: member=<irr::video::IVideoDriver::getMeshManipulator> ref=<a86> args=<()=0> -->
virtual scene::IMeshManipulator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a86">getMeshManipulator</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the mesh manipulator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a87">clearZBuffer</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note that you usually need not to call this method, as it is automatically done in <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a0">IVideoDriver::beginScene()</a> or <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a25">IVideoDriver::setRenderTarget()</a> if you enable zBuffer.  <a href="#a87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual IImage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a88">createScreenShot</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual video::ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a89">findTexture</a> (const c8 *filename)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Works similar to <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a8">getTexture()</a>, but does not load the texture if it is not currently loaded.  <a href="#a89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a90">setClipPlane</a> (u32 index, const core::plane3df &amp;plane, bool enable=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">There are at least 6 clipping planes available for the user to set at will.  <a href="#a90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a91">enableClipPlane</a> (u32 index, bool enable)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">There are at least 6 clipping planes available for the user to set at will.  <a href="#a91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a92"></a><!-- doxytag: member=<irr::video::IVideoDriver::getVendorInfo> ref=<a92> args=<()=0> -->
virtual core::stringc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a92">getVendorInfo</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the graphics card vendor name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a93">setAmbientLight</a> (const SColorf &amp;color)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ambient color is set in the scene manager, see <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a81">scene::ISceneManager::setAmbientLight()</a>.  <a href="#a93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a94">setAllowZWriteOnTransparent</a> (bool flag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Passes the global material flag AllowZWriteOnTransparent.  <a href="#a94"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This interface is one of the most important interfaces of the Irrlicht Engine: All rendering and texture manipulation is done with this interface. 
<p>
You are able to use the Irrlicht Engine by only invoking methods of this interface if you like to, although the <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html">irr::scene::ISceneManager</a> interface provides a lot of powerful classes and methods to make the programmer's life easier.
<p>

<p>
Definition at line <a class="el" href="_i_video_driver_8h-source.html#l00089">89</a> of file <a class="el" href="_i_video_driver_8h-source.html">IVideoDriver.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a56"></a><!-- doxytag: member=<irr::video::IVideoDriver::addDynamicLight> ref=<a56> args=<(const SLight &amp;light)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::addDynamicLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SLight &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>light</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>light</em>&nbsp;</td><td>Data specifying the dynamic light. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a61"></a><!-- doxytag: member=<irr::video::IVideoDriver::addExternalImageLoader> ref=<a61> args=<(IImageLoader *loader)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::addExternalImageLoader           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IImageLoader *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>loader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is useful if the Irrlicht Engine should be able to load textures of currently unsupported file formats (e.g. 
<p>
gif). The IImageLoader only needs to be implemented for loading this file format. A pointer to the implementation can be passed to the engine using this method. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>loader</em>&nbsp;</td><td>Pointer to the external loader created. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a62"></a><!-- doxytag: member=<irr::video::IVideoDriver::addExternalImageWriter> ref=<a62> args=<(IImageWriter *writer)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::addExternalImageWriter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IImageWriter *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>writer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is useful if the Irrlicht Engine should be able to write textures of currently unsupported file formats (e.g .gif). 
<p>
The IImageWriter only needs to be implemented for writing this file format. A pointer to the implementation can be passed to the engine using this method. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>writer,:</em>&nbsp;</td><td>Pointer to the external writer created. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a74"></a><!-- doxytag: member=<irr::video::IVideoDriver::addMaterialRenderer> ref=<a74> args=<(IMaterialRenderer *renderer, const c8 *name=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual s32 irr::video::IVideoDriver::addMaterialRenderer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IMaterialRenderer *&nbsp;</td>
          <td class="mdname" nowrap> <em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use this method to extend the VideoDriver with new material types. 
<p>
To extend the engine using this method do the following: Derive a class from IMaterialRenderer and override the methods you need. For setting the right renderstates, you can try to get a pointer to the real rendering device using <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a82">IVideoDriver::getExposedVideoData()</a>. Add your class with <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a74">IVideoDriver::addMaterialRenderer()</a>. To use an object being displayed with your new material, set the MaterialType member of the <a class="el" href="classirr_1_1video_1_1_s_material.html">SMaterial</a> struct to the value returned by this method. If you simply want to create a new material using vertex and/or pixel shaders it would be easier to use the video::IGPUProgrammingServices interface which you can get using the <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a85">getGPUProgrammingServices()</a> method. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>renderer</em>&nbsp;</td><td>A pointer to the new renderer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Optional name for the material renderer entry. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1_s_material.html#o0">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured. For example if you tried to add an material renderer to the software renderer or the null device, which do not accept material renderers. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16"></a><!-- doxytag: member=<irr::video::IVideoDriver::addRenderTargetTexture> ref=<a16> args=<(const core::dimension2d&lt; s32 &gt; &amp;size, const c8 *name=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITexture* irr::video::IVideoDriver::addRenderTargetTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::dimension2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the texture, in pixels. Width and height should be a power of two (e.g. 64, 128, 256, 512, ...) and it should not be bigger than the backbuffer, because it shares the zbuffer with the screen buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An optional name for the RTT. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the created texture or 0 if the texture could not be created. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15"></a><!-- doxytag: member=<irr::video::IVideoDriver::addTexture> ref=<a15> args=<(const c8 *name, IImage *image)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITexture* irr::video::IVideoDriver::addTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>IImage *&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A name for the texture. Later calls of <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a8">getTexture()</a> with this name will return this texture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Image the texture is created from. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the newly created texture. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14"></a><!-- doxytag: member=<irr::video::IVideoDriver::addTexture> ref=<a14> args=<(const core::dimension2d&lt; s32 &gt; &amp;size, const c8 *name, ECOLOR_FORMAT format=ECF_A8R8G8B8)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITexture* irr::video::IVideoDriver::addTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::dimension2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ECOLOR_FORMAT&nbsp;</td>
          <td class="mdname" nowrap> <em>format</em> = <code>ECF_A8R8G8B8</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size,:</em>&nbsp;</td><td>Size of the texture. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A name for the texture. Later calls to <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a8">getTexture()</a> with this name will return this texture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>Desired color format of the texture. Please note that the driver may choose to create the texture in another color format. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the newly created texture. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0"></a><!-- doxytag: member=<irr::video::IVideoDriver::beginScene> ref=<a0> args=<(bool backBuffer=true, bool zBuffer=true, SColor color=SColor(255, 0, 0, 0), void *windowId=0, core::rect&lt; s32 &gt; *sourceRect=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::video::IVideoDriver::beginScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname" nowrap> <em>backBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>zBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(255,&nbsp;0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>windowId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>core::rect&lt; s32 &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>sourceRect</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method can clear the back- and the z-buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>backBuffer</em>&nbsp;</td><td>Specifies if the back buffer should be cleared, which means that the screen is filled with the color specified. If this parameter is false, the back buffer will not be cleared and the color parameter is ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zBuffer</em>&nbsp;</td><td>Specifies if the depth buffer (z buffer) should be cleared. It is not nesesarry to do so if only 2d drawing is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>The color used for back buffer clearing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>windowId</em>&nbsp;</td><td>Handle of another window, if you want the bitmap to be displayed on another window. If this is null, everything will be displayed in the default window. Note: This feature is not fully implemented for all devices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceRect</em>&nbsp;</td><td>Pointer to a rectangle defining the source rectangle of the area to be presented. Set to null to present everything. Note: not implemented in all devices. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>False if failed. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4"></a><!-- doxytag: member=<irr::video::IVideoDriver::checkDriverReset> ref=<a4> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::video::IVideoDriver::checkDriverReset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
For d3d devices you will need to recreate the RTTs if the driver was reset. 
<p>
Should be queried right after <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a0">beginScene()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a87"></a><!-- doxytag: member=<irr::video::IVideoDriver::clearZBuffer> ref=<a87> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::clearZBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Note that you usually need not to call this method, as it is automatically done in <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a0">IVideoDriver::beginScene()</a> or <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a25">IVideoDriver::setRenderTarget()</a> if you enable zBuffer. 
<p>
But if you have to render some special things, you can clear the zbuffer during the rendering process with this method any time.    </td>
  </tr>
</table>
<a class="anchor" name="a80"></a><!-- doxytag: member=<irr::video::IVideoDriver::createAttributesFromMaterial> ref=<a80> args=<(const video::SMaterial &amp;material)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual io::IAttributes* irr::video::IVideoDriver::createAttributesFromMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classirr_1_1video_1_1_s_material.html">video::SMaterial</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>material</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method is useful for serialization and more. 
<p>
Please note that the video driver will use the material renderer names from <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a77">getMaterialRendererName()</a> to write out the material type name, so they should be set before. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>material</em>&nbsp;</td><td>The material to serialize. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The io::IAttributes container holding the material properties. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a72"></a><!-- doxytag: member=<irr::video::IVideoDriver::createImage> ref=<a72> args=<(IImage *imageToCopy, const core::position2d&lt; s32 &gt; &amp;pos, const core::dimension2d&lt; s32 &gt; &amp;size)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IImage* irr::video::IVideoDriver::createImage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IImage *&nbsp;</td>
          <td class="mdname" nowrap> <em>imageToCopy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::position2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>imageToCopy</em>&nbsp;</td><td>Image to copy the the new image in part. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position of rectangle to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Extents of rectangle to copy. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The created image. If you no longer need the image, you should call IImage::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a71"></a><!-- doxytag: member=<irr::video::IVideoDriver::createImage> ref=<a71> args=<(ECOLOR_FORMAT format, IImage *imageToCopy)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IImage* irr::video::IVideoDriver::createImage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ECOLOR_FORMAT&nbsp;</td>
          <td class="mdname" nowrap> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>IImage *&nbsp;</td>
          <td class="mdname" nowrap> <em>imageToCopy</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>Desired color format of the image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>imageToCopy</em>&nbsp;</td><td>Image to copy to the new image. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The created image. If you no longer need the image, you should call IImage::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a70"></a><!-- doxytag: member=<irr::video::IVideoDriver::createImage> ref=<a70> args=<(ECOLOR_FORMAT format, const core::dimension2d&lt; s32 &gt; &amp;size)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IImage* irr::video::IVideoDriver::createImage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ECOLOR_FORMAT&nbsp;</td>
          <td class="mdname" nowrap> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>Desired color format of the image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the image to create. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The created image. If you no longer need the image, you should call IImage::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a69"></a><!-- doxytag: member=<irr::video::IVideoDriver::createImageFromData> ref=<a69> args=<(ECOLOR_FORMAT format, const core::dimension2d&lt; s32 &gt; &amp;size, void *data, bool ownForeignMemory=false, bool deleteMemory=true)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IImage* irr::video::IVideoDriver::createImageFromData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ECOLOR_FORMAT&nbsp;</td>
          <td class="mdname" nowrap> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::dimension2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>ownForeignMemory</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>deleteMemory</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
No hardware texture will be created for this image. 
<p>
This method is useful for example if you want to read a heightmap for a terrain renderer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>Desired color format of the texture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Desired size of the image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A byte array with pixel color information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownForeignMemory</em>&nbsp;</td><td>If true, the image will use the data pointer directly and own it afterwards. If false, the memory will by copied internally. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deleteMemory</em>&nbsp;</td><td>Whether the memory is deallocated upon destruction. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The created image. If you no longer need the image, you should call IImage::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a67"></a><!-- doxytag: member=<irr::video::IVideoDriver::createImageFromFile> ref=<a67> args=<(io::IReadFile *file)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IImage* irr::video::IVideoDriver::createImageFromFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">io::IReadFile *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>file</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
No hardware texture will be created for this image. 
<p>
This method is useful for example if you want to read a heightmap for a terrain renderer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>File from which the image is created. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The created image. If you no longer need the image, you should call IImage::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a66"></a><!-- doxytag: member=<irr::video::IVideoDriver::createImageFromFile> ref=<a66> args=<(const c8 *filename)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IImage* irr::video::IVideoDriver::createImageFromFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>filename</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
No hardware texture will be created for this image. 
<p>
This method is useful for example if you want to read a heightmap for a terrain renderer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Name of the file from which the image is created. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The created image. If you no longer need the image, you should call IImage::drop(). See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17"></a><!-- doxytag: member=<irr::video::IVideoDriver::createRenderTargetTexture> ref=<a17> args=<(const core::dimension2d&lt; s32 &gt; &amp;size, const c8 *name=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITexture* irr::video::IVideoDriver::createRenderTargetTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::dimension2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>use addRenderTargetTexture instead.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a88"></a><!-- doxytag: member=<irr::video::IVideoDriver::createScreenShot> ref=<a88> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IImage* irr::video::IVideoDriver::createScreenShot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>An image created from the last rendered frame. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3"></a><!-- doxytag: member=<irr::video::IVideoDriver::disableFeature> ref=<a3> args=<(E_VIDEO_DRIVER_FEATURE feature, bool flag=true)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::disableFeature           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">E_VIDEO_DRIVER_FEATURE&nbsp;</td>
          <td class="mdname" nowrap> <em>feature</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>flag</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Can also be used to enable the features again. 
<p>
It is not possible to enable unsupported features this way, though. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>feature</em>&nbsp;</td><td>Feature to disable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>When true the feature is disabled, otherwise it is enabled. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a40"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw2DImage> ref=<a40> args=<(const video::ITexture *texture, const core::rect&lt; s32 &gt; &amp;destRect, const core::rect&lt; s32 &gt; &amp;sourceRect, const core::rect&lt; s32 &gt; *clipRect=0, const video::SColor *const colors=0, bool useAlphaChannelOfTexture=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw2DImage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>destRect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>sourceRect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const video::SColor *const &nbsp;</td>
          <td class="mdname" nowrap> <em>colors</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>useAlphaChannelOfTexture</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suggested and first implemented by zola. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>The texture to draw from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destRect</em>&nbsp;</td><td>The rectangle to draw into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceRect</em>&nbsp;</td><td>The rectangle denoting a part of the texture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clipRect</em>&nbsp;</td><td>Clips the destination rectangle (may be 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colors</em>&nbsp;</td><td>Array of 4 colors denoting the color values of the corners of the destRect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useAlphaChannelOfTexture</em>&nbsp;</td><td>True if alpha channel will be blended. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a39"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw2DImage> ref=<a39> args=<(const video::ITexture *texture, const core::position2d&lt; s32 &gt; &amp;pos, const core::array&lt; core::rect&lt; s32 &gt; &gt; &amp;sourceRects, const core::array&lt; s32 &gt; &amp;indices, s32 kerningWidth=0, const core::rect&lt; s32 &gt; *clipRect=0, SColor color=SColor(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw2DImage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::position2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::array&lt; core::rect&lt; s32 &gt; &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>sourceRects</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::array&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>indices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>kerningWidth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(255,&nbsp;255,&nbsp;255,&nbsp;255)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>useAlphaChannelOfTexture</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The images are drawn beginning at pos and concatenated in one line. 
<p>
All drawings are clipped against clipRect (if != 0). The subtextures are defined by the array of sourceRects and are chosen by the indices given. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>Texture to be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceRects</em>&nbsp;</td><td>Source rectangles of the image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>List of indices which choose the actual rectangle used each time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kerningWidth</em>&nbsp;</td><td>Offset to Position on X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clipRect</em>&nbsp;</td><td>Pointer to rectangle on the screen where the image is clipped to. If this pointer is 0 then the image is not clipped. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color with which the image is drawn. Note that the alpha component is used. If alpha is other than 255, the image will be transparent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useAlphaChannelOfTexture,:</em>&nbsp;</td><td>If true, the alpha channel of the texture is used to draw the image. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a38"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw2DImage> ref=<a38> args=<(const video::ITexture *texture, const core::position2d&lt; s32 &gt; &amp;destPos, const core::rect&lt; s32 &gt; &amp;sourceRect, const core::rect&lt; s32 &gt; *clipRect=0, SColor color=SColor(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw2DImage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::position2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>sourceRect</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>clipRect</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(255,&nbsp;255,&nbsp;255,&nbsp;255)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>useAlphaChannelOfTexture</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
(if color is other than Color(255,255,255,255)) and the alpha channel of the texture. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>Texture to be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destPos</em>&nbsp;</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceRect</em>&nbsp;</td><td>Source rectangle in the image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clipRect</em>&nbsp;</td><td>Pointer to rectangle on the screen where the image is clipped to. If this pointer is NULL the image is not clipped. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color with which the image is drawn. If the color equals Color(255,255,255,255) it is ignored. Note that the alpha component is used: If alpha is other than 255, the image will be transparent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useAlphaChannelOfTexture,:</em>&nbsp;</td><td>If true, the alpha channel of the texture is used to draw the image. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a37"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw2DImage> ref=<a37> args=<(const video::ITexture *texture, const core::position2d&lt; s32 &gt; &amp;destPos)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw2DImage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::position2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>destPos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>Pointer to texture to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destPos</em>&nbsp;</td><td>Upper left 2d destination position where the image will be drawn. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a43"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw2DLine> ref=<a43> args=<(const core::position2d&lt; s32 &gt; &amp;start, const core::position2d&lt; s32 &gt; &amp;end, SColor color=SColor(255, 255, 255, 255))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw2DLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::position2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::position2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(255,&nbsp;255,&nbsp;255,&nbsp;255)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start,:</em>&nbsp;</td><td>Screen coordinates of the start of the line in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end,:</em>&nbsp;</td><td>Screen coordinates of the start of the line in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color,:</em>&nbsp;</td><td>Color of the line to draw. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a45"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw2DPolygon> ref=<a45> args=<(core::position2d&lt; s32 &gt; center, f32 radius, video::SColor color=SColor(100, 255, 255, 255), s32 vertexCount=10)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw2DPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">core::position2d&lt; s32 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(100,&nbsp;255,&nbsp;255,&nbsp;255)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexCount</em> = <code>10</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method can be used to draw circles, but also triangles, tetragons, pentagons, hexagons, heptagons, octagons, enneagons, decagons, hendecagons, dodecagon, triskaidecagons, etc. 
<p>
I think you'll got it now. And all this by simply specifying the vertex count. Welcome to the wonders of geometry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>Position of center of circle (pixels). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>Radius of circle in pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color of the circle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>Amount of vertices of the polygon. Specify 2 to draw a line, 3 to draw a triangle, 4 for tetragons and a lot (&gt;10) for nearly a circle. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a42"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw2DRectangle> ref=<a42> args=<(const core::rect&lt; s32 &gt; &amp;pos, SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown, const core::rect&lt; s32 &gt; *clip=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw2DRectangle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::rect&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>colorLeftUp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>colorRightUp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>colorLeftDown</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>colorRightDown</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>clip</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>colorLeftUp</em>&nbsp;</td><td>Color of the upper left corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorRightUp</em>&nbsp;</td><td>Color of the upper right corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorLeftDown</em>&nbsp;</td><td>Color of the lower left corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorRightDown</em>&nbsp;</td><td>Color of the lower right corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position of the rectangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clip</em>&nbsp;</td><td>Pointer to rectangle against which the rectangle will be clipped. If the pointer is null, no clipping will be performed. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a41"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw2DRectangle> ref=<a41> args=<(SColor color, const core::rect&lt; s32 &gt; &amp;pos, const core::rect&lt; s32 &gt; *clip=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw2DRectangle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::rect&lt; s32 &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>clip</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color of the rectangle to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position of the rectangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clip</em>&nbsp;</td><td>Pointer to rectangle against which the rectangle will be clipped. If the pointer is null, no clipping will be performed. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw3DBox> ref=<a36> args=<(const core::aabbox3d&lt; f32 &gt; &amp;box, SColor color=SColor(255, 255, 255, 255))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw3DBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::aabbox3d&lt; f32 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(255,&nbsp;255,&nbsp;255,&nbsp;255)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method simply calls draw3DLine for the edges of the box. 
<p>
Note that the box is drawn using the current transformation matrix and material. So if you need to draw it independently of the current transformation, use <div class="fragment"><pre class="fragment">                driver-&gt;setMaterial(unlitMaterial);
                driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a36a1">video::ETS_WORLD</a>, core::matrix4());
</pre></div> for some properly set up material before drawing the box. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>The axis aligned box to draw </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color to use while drawing the box. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a34"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw3DLine> ref=<a34> args=<(const core::vector3df &amp;start, const core::vector3df &amp;end, SColor color=SColor(255, 255, 255, 255))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw3DLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::vector3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(255,&nbsp;255,&nbsp;255,&nbsp;255)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
For some implementations, this method simply calls drawIndexedTriangles for some triangles. 
<p>
Note that the line is drawn using the current transformation matrix and material. So if you need to draw the 3D line independently of the current transformation, use <div class="fragment"><pre class="fragment">                driver-&gt;setMaterial(unlitMaterial);
                driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a36a1">video::ETS_WORLD</a>, core::matrix4());
</pre></div> for some properly set up material before drawing the line. Some drivers support line thickness set in the material. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start of the 3d line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of the 3d line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color of the line. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35"></a><!-- doxytag: member=<irr::video::IVideoDriver::draw3DTriangle> ref=<a35> args=<(const core::triangle3df &amp;triangle, SColor color=SColor(255, 255, 255, 255))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::draw3DTriangle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::triangle3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(255,&nbsp;255,&nbsp;255,&nbsp;255)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method calls drawIndexedTriangles for some triangles. 
<p>
This method works with all drivers because it simply calls drawIndexedTriangleList but it is hence not very fast. Note that the triangle is drawn using the current transformation matrix and material. So if you need to draw it independently of the current transformation, use <div class="fragment"><pre class="fragment">                driver-&gt;setMaterial(unlitMaterial);
                driver-&gt;setTransform(<a class="code" href="namespaceirr_1_1video.html#a36a1">video::ETS_WORLD</a>, core::matrix4());
</pre></div> for some properly set up material before drawing the triangle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>triangle</em>&nbsp;</td><td>The triangle to draw. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color of the line. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawIndexedTriangleFan> ref=<a33> args=<(const S3DVertex2TCoords *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawIndexedTriangleFan           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const S3DVertex2TCoords *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>triangleCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. 
<p>
If there are more than 65536 vertices in the list, results of this operation are not defined. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>Pointer to array of vertices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>Amount of vertices in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexList</em>&nbsp;</td><td>Pointer to array of indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>triangleCount</em>&nbsp;</td><td>Amount of Triangles. Usually amount of indices - 2. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a32"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawIndexedTriangleFan> ref=<a32> args=<(const S3DVertex *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawIndexedTriangleFan           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const S3DVertex *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>triangleCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. 
<p>
If there are more than 65536 vertices in the list, results of this operation are not defined. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>Pointer to array of vertices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>Amount of vertices in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexList</em>&nbsp;</td><td>Pointer to array of indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>triangleCount</em>&nbsp;</td><td>Amount of Triangles. Usually amount of indices - 2. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawIndexedTriangleList> ref=<a31> args=<(const S3DVertexTangents *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawIndexedTriangleList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const S3DVertexTangents *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>triangleCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. 
<p>
If there are more than 65536 vertices in the list, results of this operation are not defined. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>Pointer to array of vertices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>Amount of vertices in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexList</em>&nbsp;</td><td>Pointer to array of indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>triangleCount</em>&nbsp;</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawIndexedTriangleList> ref=<a30> args=<(const S3DVertex2TCoords *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawIndexedTriangleList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const S3DVertex2TCoords *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>triangleCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. 
<p>
If there are more than 65536 vertices in the list, results of this operation are not defined. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>Pointer to array of vertices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>Amount of vertices in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexList</em>&nbsp;</td><td>Pointer to array of indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>triangleCount</em>&nbsp;</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawIndexedTriangleList> ref=<a29> args=<(const S3DVertex *vertices, u32 vertexCount, const u16 *indexList, u32 triangleCount)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawIndexedTriangleList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const S3DVertex *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>triangleCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. 
<p>
If there are more than 65536 vertices in the list, results of this operation are not defined. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>Pointer to array of vertices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>Amount of vertices in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexList</em>&nbsp;</td><td>Pointer to array of indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>triangleCount</em>&nbsp;</td><td>Amount of Triangles. Usually amount of indices / 3. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a48"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawMeshBuffer> ref=<a48> args=<(const scene::IMeshBuffer *mb)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawMeshBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const scene::IMeshBuffer *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mb,:</em>&nbsp;</td><td>Buffer to draw; </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a44"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawPixel> ref=<a44> args=<(u32 x, u32 y, const SColor &amp;color)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawPixel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const SColor &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position,:</em>&nbsp;</td><td>the position of the pixel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color,:</em>&nbsp;</td><td>Color of the pixel to draw. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a47"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawStencilShadow> ref=<a47> args=<(bool clearStencilBuffer=false, video::SColor leftUpEdge=video::SColor(255, 0, 0, 0), video::SColor rightUpEdge=video::SColor(255, 0, 0, 0), video::SColor leftDownEdge=video::SColor(255, 0, 0, 0), video::SColor rightDownEdge=video::SColor(255, 0, 0, 0))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawStencilShadow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname" nowrap> <em>clearStencilBuffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>leftUpEdge</em> = <code>video::SColor(255,&nbsp;0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>rightUpEdge</em> = <code>video::SColor(255,&nbsp;0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>leftDownEdge</em> = <code>video::SColor(255,&nbsp;0,&nbsp;0,&nbsp;0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>rightDownEdge</em> = <code>video::SColor(255,&nbsp;0,&nbsp;0,&nbsp;0)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
After the shadow volume has been drawn into the stencil buffer using <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a46">IVideoDriver::drawStencilShadowVolume()</a>, use this to draw the color of the shadow. 
<p>
Please note that the code for the opengl version of the method is based on free code sent in by Philipp Dortmann, lots of thanks go to him! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clearStencilBuffer</em>&nbsp;</td><td>Set this to false, if you want to draw every shadow with the same color, and only want to call <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a47">drawStencilShadow()</a> once after all shadow volumes have been drawn. Set this to true, if you want to paint every shadow with its own color. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>leftUpEdge</em>&nbsp;</td><td>Color of the shadow in the upper left corner of screen. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rightUpEdge</em>&nbsp;</td><td>Color of the shadow in the upper right corner of screen. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>leftDownEdge</em>&nbsp;</td><td>Color of the shadow in the lower left corner of screen. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rightDownEdge</em>&nbsp;</td><td>Color of the shadow in the lower right corner of screen. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a46"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawStencilShadowVolume> ref=<a46> args=<(const core::vector3df *triangles, s32 count, bool zfail=true)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawStencilShadowVolume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::vector3df *&nbsp;</td>
          <td class="mdname" nowrap> <em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>zfail</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
To draw a stencil shadow, do this: First, draw all geometry. 
<p>
Then use this method, to draw the shadow volume. Then, use <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a47">IVideoDriver::drawStencilShadow()</a> to visualize the shadow. Please note that the code for the opengl version of the method is based on free code sent in by Philipp Dortmann, lots of thanks go to him! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>triangles</em>&nbsp;</td><td>Pointer to array of 3d vectors, specifying the shadow volume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Amount of triangles in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zfail</em>&nbsp;</td><td>If set to true, zfail method is used, otherwise zpass. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28"></a><!-- doxytag: member=<irr::video::IVideoDriver::drawVertexPrimitiveList> ref=<a28> args=<(const void *vertices, u32 vertexCount, const void *indexList, u32 primCount, E_VERTEX_TYPE vType, scene::E_PRIMITIVE_TYPE pType, E_INDEX_TYPE iType)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::drawVertexPrimitiveList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>primCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>E_VERTEX_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>vType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>scene::E_PRIMITIVE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>pType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>E_INDEX_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>iType</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Note that there may be at maximum 65536 vertices, because the index list is an array of 16 bit values each with a maximum value of 65536. 
<p>
If there are more than 65536 vertices in the list, results of this operation are not defined. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>Pointer to array of vertices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexCount</em>&nbsp;</td><td>Amount of vertices in the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexList</em>&nbsp;</td><td>Pointer to array of indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>primCount</em>&nbsp;</td><td>Amount of Primitives </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vType</em>&nbsp;</td><td>Vertex type, e.g. EVT_STANDARD for S3DVertex. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pType</em>&nbsp;</td><td>Primitive type, e.g. EPT_TRIANGLE_FAN for a triangle fan. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a91"></a><!-- doxytag: member=<irr::video::IVideoDriver::enableClipPlane> ref=<a91> args=<(u32 index, bool enable)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::enableClipPlane           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname" nowrap> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>enable</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
There are at least 6 clipping planes available for the user to set at will. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The plane index. Must be between 0 and MaxUserClipPlanes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>If true, enable the clipping plane else disable it. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1"></a><!-- doxytag: member=<irr::video::IVideoDriver::endScene> ref=<a1> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::video::IVideoDriver::endScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applications must call this method after performing any rendering. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>False if failed and true if succeeded. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a81"></a><!-- doxytag: member=<irr::video::IVideoDriver::fillMaterialStructureFromAttributes> ref=<a81> args=<(video::SMaterial &amp;outMaterial, io::IAttributes *attributes)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::fillMaterialStructureFromAttributes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classirr_1_1video_1_1_s_material.html">video::SMaterial</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outMaterial</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>io::IAttributes *&nbsp;</td>
          <td class="mdname" nowrap> <em>attributes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Please note that for setting material types of the material, the video driver will need to query the material renderers for their names, so all non built-in materials must have been created before calling this method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>outMaterial</em>&nbsp;</td><td>The material to set the properties for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attributes</em>&nbsp;</td><td>The attributes to read from. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a78"></a><!-- doxytag: member=<irr::video::IVideoDriver::findMaterialRendererId> ref=<a78> args=<(const c8 *name)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual s32 irr::video::IVideoDriver::findMaterialRendererId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the id of a the material renderer with the name <code>name</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The material name to find. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the index of the material renderer or -1 if no material was found. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classirr_1_1video_1_1_i_material_system.html">IMaterialSystem</a>.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a89"></a><!-- doxytag: member=<irr::video::IVideoDriver::findTexture> ref=<a89> args=<(const c8 *filename)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual video::ITexture* irr::video::IVideoDriver::findTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>filename</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Works similar to <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a8">getTexture()</a>, but does not load the texture if it is not currently loaded. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Name of the texture. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to loaded texture, or 0 if not found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a50"></a><!-- doxytag: member=<irr::video::IVideoDriver::getColorFormat> ref=<a50> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ECOLOR_FORMAT irr::video::IVideoDriver::getColorFormat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Color format of the color buffer. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a52"></a><!-- doxytag: member=<irr::video::IVideoDriver::getCurrentRenderTargetSize> ref=<a52> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const core::dimension2d&lt;s32&gt;&amp; irr::video::IVideoDriver::getCurrentRenderTargetSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method will return the screen size if the driver doesn't support render to texture, or if the current render target is the screen. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Size of render target or screen/window </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a83"></a><!-- doxytag: member=<irr::video::IVideoDriver::getDriverType> ref=<a83> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual E_DRIVER_TYPE irr::video::IVideoDriver::getDriverType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Type of driver. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a59"></a><!-- doxytag: member=<irr::video::IVideoDriver::getDynamicLight> ref=<a59> args=<(u32 idx) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const SLight&amp; irr::video::IVideoDriver::getDynamicLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>idx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Zero based index of the light. Must be 0 or greater and smaller than IVideoDriver()getDynamicLightCount. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Light data. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a58"></a><!-- doxytag: member=<irr::video::IVideoDriver::getDynamicLightCount> ref=<a58> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual u32 irr::video::IVideoDriver::getDynamicLightCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Amount of dynamic lights currently set </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a82"></a><!-- doxytag: member=<irr::video::IVideoDriver::getExposedVideoData> ref=<a82> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const SExposedVideoData&amp; irr::video::IVideoDriver::getExposedVideoData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method should only be used if the engine should be extended without having to modify the source of the engine. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Collection of device dependent pointers. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a53"></a><!-- doxytag: member=<irr::video::IVideoDriver::getFPS> ref=<a53> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual s32 irr::video::IVideoDriver::getFPS           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This value is updated approximately every 1.5 seconds and is only intended to provide a rough guide to the average frame rate. 
<p>
It is not suitable for use in performing timing calculations or framerate independent movement. <dl compact><dt><b>Returns:</b></dt><dd>Approximate amount of frames per second drawn. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a85"></a><!-- doxytag: member=<irr::video::IVideoDriver::getGPUProgrammingServices> ref=<a85> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IGPUProgrammingServices* irr::video::IVideoDriver::getGPUProgrammingServices           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the IGPUProgrammingServices. Returns 0 if the video driver does not support this. For example the Software driver and the Null driver will always return 0. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a75"></a><!-- doxytag: member=<irr::video::IVideoDriver::getMaterialRenderer> ref=<a75> args=<(u32 idx)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual IMaterialRenderer* irr::video::IVideoDriver::getMaterialRenderer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>idx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a74">addMaterialRenderer()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to material renderer or null if not existing. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a76"></a><!-- doxytag: member=<irr::video::IVideoDriver::getMaterialRendererCount> ref=<a76> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual u32 irr::video::IVideoDriver::getMaterialRendererCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Amount of currently available material renderers. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a77"></a><!-- doxytag: member=<irr::video::IVideoDriver::getMaterialRendererName> ref=<a77> args=<(u32 idx) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const c8* irr::video::IVideoDriver::getMaterialRendererName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>idx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This string can, e.g. 
<p>
, be used to test if a specific renderer already has been registered/created, or use this string to store data about materials: This returned name will be also used when serializing materials. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a74">addMaterialRenderer()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>String with the name of the renderer, or 0 if not exisiting </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a84"></a><!-- doxytag: member=<irr::video::IVideoDriver::getMaterialSystem> ref=<a84> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classirr_1_1video_1_1_i_material_system.html">IMaterialSystem</a>* irr::video::IVideoDriver::getMaterialSystem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the Material System. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the Material System </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classirr_1_1video_1_1_i_material_system.html">IMaterialSystem</a>.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a57"></a><!-- doxytag: member=<irr::video::IVideoDriver::getMaximalDynamicLightAmount> ref=<a57> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual u32 irr::video::IVideoDriver::getMaximalDynamicLightAmount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Maximal amount of dynamic lights. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a63"></a><!-- doxytag: member=<irr::video::IVideoDriver::getMaximalPrimitiveCount> ref=<a63> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual u32 irr::video::IVideoDriver::getMaximalPrimitiveCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
(mostly vertices) which the device is able to render with one drawIndexedTriangleList call. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Maximum amount of primitives. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a60"></a><!-- doxytag: member=<irr::video::IVideoDriver::getName> ref=<a60> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const wchar_t* irr::video::IVideoDriver::getName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the name of the video driver, e.g. in case of the Direct3D8 driver, it would return "Direct3D 8.1". </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a54"></a><!-- doxytag: member=<irr::video::IVideoDriver::getPrimitiveCountDrawn> ref=<a54> args=<(u32 mode=0) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual u32 irr::video::IVideoDriver::getPrimitiveCountDrawn           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Together with <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a53">getFPS()</a> very useful method for statistics. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Defines if the primitives drawn are accumulated or counted per frame. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Amount of primitives drawn in the last frame. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a51"></a><!-- doxytag: member=<irr::video::IVideoDriver::getScreenSize> ref=<a51> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const core::dimension2d&lt;s32&gt;&amp; irr::video::IVideoDriver::getScreenSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Size of screen or render window. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10"></a><!-- doxytag: member=<irr::video::IVideoDriver::getTexture> ref=<a10> args=<(io::IReadFile *file)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITexture* irr::video::IVideoDriver::getTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">io::IReadFile *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>file</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. 
<p>
Texture loading can be influenced using the <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a64">setTextureCreationFlag()</a> method. The texture can be in several imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>Pointer to an already opened file. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9"></a><!-- doxytag: member=<irr::video::IVideoDriver::getTexture> ref=<a9> args=<(const core::stringc &amp;filename)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITexture* irr::video::IVideoDriver::getTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::stringc &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>filename</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. 
<p>
Texture loading can be influenced using the <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a64">setTextureCreationFlag()</a> method. The texture can be in several imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Filename of the texture to be loaded. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8"></a><!-- doxytag: member=<irr::video::IVideoDriver::getTexture> ref=<a8> args=<(const c8 *filename)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITexture* irr::video::IVideoDriver::getTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const c8 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>filename</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. 
<p>
Texture loading can be influenced using the <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a64">setTextureCreationFlag()</a> method. The texture can be in several imageformats, such as BMP, JPG, TGA, PCX, PNG, and PSD. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Filename of the texture to be loaded. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11"></a><!-- doxytag: member=<irr::video::IVideoDriver::getTextureByIndex> ref=<a11> args=<(u32 index)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ITexture* irr::video::IVideoDriver::getTextureByIndex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index,:</em>&nbsp;</td><td>Index of the texture, must be smaller than <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a12">getTextureCount()</a> Please note that this index might change when adding or removing textures </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the texture, or 0 if the texture was not set or index is out of bounds. This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member=<irr::video::IVideoDriver::getTextureCount> ref=<a12> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual u32 irr::video::IVideoDriver::getTextureCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Amount of textures currently loaded </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a65"></a><!-- doxytag: member=<irr::video::IVideoDriver::getTextureCreationFlag> ref=<a65> args=<(E_TEXTURE_CREATION_FLAG flag) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::video::IVideoDriver::getTextureCreationFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">E_TEXTURE_CREATION_FLAG&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
You can change this value using setTextureCreationMode(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>Texture creation flag. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The current texture creation mode. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6"></a><!-- doxytag: member=<irr::video::IVideoDriver::getTransform> ref=<a6> args=<(E_TRANSFORMATION_STATE state) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const core::matrix4&amp; irr::video::IVideoDriver::getTransform           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirr_1_1video.html#a36">E_TRANSFORMATION_STATE</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Transformation type to query </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Matrix describing the transformation. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27"></a><!-- doxytag: member=<irr::video::IVideoDriver::getViewPort> ref=<a27> args=<() const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const core::rect&lt;s32&gt;&amp; irr::video::IVideoDriver::getViewPort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Rectangle of the current viewport. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23"></a><!-- doxytag: member=<irr::video::IVideoDriver::makeColorKeyTexture> ref=<a23> args=<(video::ITexture *texture, core::position2d&lt; s32 &gt; colorKeyPixelPos) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::makeColorKeyTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>core::position2d&lt; s32 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>colorKeyPixelPos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This makes the texture transparent at the regions where this color key can be found when using for example draw2DImage with useAlphachannel==true. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colorKeyPixelPos</em>&nbsp;</td><td>Position of a pixel with the color key color. Every pixel with this color will become transparent as described above. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22"></a><!-- doxytag: member=<irr::video::IVideoDriver::makeColorKeyTexture> ref=<a22> args=<(video::ITexture *texture, video::SColor color) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::makeColorKeyTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>video::SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This makes the texture transparent at the regions where this color key can be found when using for example draw2DImage with useAlphachannel==true. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color key color. Every pixel with this color will become transparent as described above. Please note that the colors of a texture may be converted when loading it, so the color values may not be exactly the same in the engine and for example in picture edit programs. To avoid this problem, you could use the makeColorKeyTexture method, which takes the position of a pixel instead a color value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24"></a><!-- doxytag: member=<irr::video::IVideoDriver::makeNormalMapTexture> ref=<a24> args=<(video::ITexture *texture, f32 amplitude=1.0f) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::makeNormalMapTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>amplitude</em> = <code>1.0f</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If the target texture has 32 bit, the height value is stored in the alpha component of the texture as addition. 
<p>
This value is used by the video::EMT_PARALLAX_MAP_SOLID material and similar materials. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>Texture whose alpha channel is modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>amplitude</em>&nbsp;</td><td>Constant value by which the height information is multiplied. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a73"></a><!-- doxytag: member=<irr::video::IVideoDriver::OnResize> ref=<a73> args=<(const core::dimension2d&lt; s32 &gt; &amp;size)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::OnResize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::dimension2d&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Used to notify the driver that the window was resized. 
<p>
Usually, there is no need to call this method.     </td>
  </tr>
</table>
<a class="anchor" name="a2"></a><!-- doxytag: member=<irr::video::IVideoDriver::queryFeature> ref=<a2> args=<(E_VIDEO_DRIVER_FEATURE feature) const =0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::video::IVideoDriver::queryFeature           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">E_VIDEO_DRIVER_FEATURE&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>feature</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if a feature is available. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>feature</em>&nbsp;</td><td>Feature to query. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the feature is available, false if not. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19"></a><!-- doxytag: member=<irr::video::IVideoDriver::removeAllTextures> ref=<a19> args=<()=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::removeAllTextures           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method can free a lot of memory! Please note that after calling this, the pointer to the ITexture may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer. 
<p>
So it is a good idea to set all materials which are using this texture to 0 or another texture first.     </td>
  </tr>
</table>
<a class="anchor" name="a18"></a><!-- doxytag: member=<irr::video::IVideoDriver::removeTexture> ref=<a18> args=<(ITexture *texture)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::removeTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ITexture *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>texture</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method can free a lot of memory! Please note that after calling this, the pointer to the ITexture may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer. 
<p>
So it is a good idea to set all materials which are using this texture to 0 or another texture first. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>Texture to delete from the engine cache. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member=<irr::video::IVideoDriver::renameTexture> ref=<a13> args=<(ITexture *texture, const c8 *newName)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::renameTexture           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>newName</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>Pointer to the texture to rename. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newName</em>&nbsp;</td><td>New name for the texture. This should be a unique name. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a94"></a><!-- doxytag: member=<irr::video::IVideoDriver::setAllowZWriteOnTransparent> ref=<a94> args=<(bool flag)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::setAllowZWriteOnTransparent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Passes the global material flag AllowZWriteOnTransparent. 
<p>
Use the SceneManager attribute to set this value from your app. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>Default behavior is to disable ZWrite, i.e. false. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a93"></a><!-- doxytag: member=<irr::video::IVideoDriver::setAmbientLight> ref=<a93> args=<(const SColorf &amp;color)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::setAmbientLight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SColorf &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>color</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The ambient color is set in the scene manager, see <a class="el" href="classirr_1_1scene_1_1_i_scene_manager.html#a81">scene::ISceneManager::setAmbientLight()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>New color of the ambient light. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a90"></a><!-- doxytag: member=<irr::video::IVideoDriver::setClipPlane> ref=<a90> args=<(u32 index, const core::plane3df &amp;plane, bool enable=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::video::IVideoDriver::setClipPlane           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname" nowrap> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::plane3df &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>enable</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
There are at least 6 clipping planes available for the user to set at will. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The plane index. Must be between 0 and MaxUserClipPlanes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>The plane itself. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>If true, enable the clipping plane else disable it. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the clipping plane is usable. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a49"></a><!-- doxytag: member=<irr::video::IVideoDriver::setFog> ref=<a49> args=<(SColor color=SColor(0, 255, 255, 255), bool linearFog=true, f32 start=50.0f, f32 end=100.0f, f32 density=0.01f, bool pixelFog=false, bool rangeFog=false)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::setFog           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>SColor(0,&nbsp;255,&nbsp;255,&nbsp;255)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>linearFog</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em> = <code>50.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>end</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f32&nbsp;</td>
          <td class="mdname" nowrap> <em>density</em> = <code>0.01f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>pixelFog</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>rangeFog</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
These are global values attached to each 3d object rendered, which has the fog flag enabled in its material. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>Color of the fog </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linearFog</em>&nbsp;</td><td>Set this to true for linear fog, otherwise exponential fog is applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Only used in linear fog mode (linearFog=true). Specifies where fog starts. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Only used in linear fog mode (linearFog=true). Specifies where fog ends. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>density</em>&nbsp;</td><td>Only used in exponential fog mode (linearFog=false). Must be a value between 0 and 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelFog</em>&nbsp;</td><td>Set this to false for vertex fog, and true if you want per-pixel fog. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rangeFog</em>&nbsp;</td><td>Set this to true to enable range-based vertex fog. The distance from the viewer is used to compute the fog, not the z-coordinate. This is better, but slower. This is only available with D3D and vertex fog. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7"></a><!-- doxytag: member=<irr::video::IVideoDriver::setMaterial> ref=<a7> args=<(const SMaterial &amp;material)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::setMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classirr_1_1video_1_1_s_material.html">SMaterial</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>material</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
All 3d drawing functions will draw geometry using this material thereafter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>material,:</em>&nbsp;</td><td>Material to be used from now on. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a79"></a><!-- doxytag: member=<irr::video::IVideoDriver::setMaterialRendererName> ref=<a79> args=<(s32 idx, const c8 *name)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::setMaterialRendererName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s32&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Will have no effect on built-in material renderers. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx,:</em>&nbsp;</td><td>Id of the material renderer. Can be a value of the E_MATERIAL_TYPE enum or a value which was returned by <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a74">addMaterialRenderer()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name,:</em>&nbsp;</td><td>New name of the material renderer. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25"></a><!-- doxytag: member=<irr::video::IVideoDriver::setRenderTarget> ref=<a25> args=<(video::ITexture *texture, bool clearBackBuffer=true, bool clearZBuffer=true, SColor color=video::SColor(0, 0, 0, 0))=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::video::IVideoDriver::setRenderTarget           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">video::ITexture *&nbsp;</td>
          <td class="mdname" nowrap> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>clearBackBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>clearZBuffer</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SColor&nbsp;</td>
          <td class="mdname" nowrap> <em>color</em> = <code>video::SColor(0,&nbsp;0,&nbsp;0,&nbsp;0)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This will only work if the driver supports the EVDF_RENDER_TO_TARGET feature, which can be queried with <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a2">queryFeature()</a>. 
<p>
Usually, rendering to textures is done in this way: <div class="fragment"><pre class="fragment">                <span class="comment">// create render target</span>
                ITexture* target = driver-&gt;addRenderTargetTexture(core::dimension2d&lt;s32&gt;(128,128), <span class="stringliteral">"rtt1"</span>);

                <span class="comment">// ...</span>

                driver-&gt;setRenderTarget(target); <span class="comment">// set render target</span>
                <span class="comment">// .. draw stuff here</span>
                driver-&gt;setRenderTarget(0); <span class="comment">// set previous render target</span>
</pre></div> Please note that you cannot render 3D or 2D geometry with a render target as texture on it when you are rendering the scene into this render target at the same time. It is usually only possible to render into a texture between the <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a0">IVideoDriver::beginScene()</a> and <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a1">endScene()</a> method calls. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>New render target. Must be a texture created with <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a16">IVideoDriver::addRenderTargetTexture()</a>. If set to 0, it sets the previous render target which was set before the last <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a25">setRenderTarget()</a> call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clearBackBuffer</em>&nbsp;</td><td>Clears the backbuffer of the render target with the color parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clearZBuffer</em>&nbsp;</td><td>Clears the zBuffer of the rendertarget. Note that because the frame buffer may share the zbuffer with the rendertarget, its zbuffer might be partially cleared too by this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>The background color for the render target. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if sucessful and false if not. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a64"></a><!-- doxytag: member=<irr::video::IVideoDriver::setTextureCreationFlag> ref=<a64> args=<(E_TEXTURE_CREATION_FLAG flag, bool enabled)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::setTextureCreationFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">E_TEXTURE_CREATION_FLAG&nbsp;</td>
          <td class="mdname" nowrap> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>enabled</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
These flags define how textures should be created. 
<p>
By changing this value, you can influence for example the speed of rendering a lot. But please note that the video drivers take this value only as recommendation. It could happen that you enable the ETCF_ALWAYS_16_BIT mode, but the driver still creates 32 bit textures. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>Texture creation flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>Specifies if the given flag should be enabled or disabled. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5"></a><!-- doxytag: member=<irr::video::IVideoDriver::setTransform> ref=<a5> args=<(E_TRANSFORMATION_STATE state, const core::matrix4 &amp;mat)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::setTransform           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceirr_1_1video.html#a36">E_TRANSFORMATION_STATE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const core::matrix4 &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mat</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Transformation type to be set, e.g. view, world, or projection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>Matrix describing the transformation. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26"></a><!-- doxytag: member=<irr::video::IVideoDriver::setViewPort> ref=<a26> args=<(const core::rect&lt; s32 &gt; &amp;area)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void irr::video::IVideoDriver::setViewPort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const core::rect&lt; s32 &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>area</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Every rendering operation is done into this new area. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>area,:</em>&nbsp;</td><td>Rectangle defining the new area of rendering operations. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a68"></a><!-- doxytag: member=<irr::video::IVideoDriver::writeImageToFile> ref=<a68> args=<(IImage *image, const c8 *filename, u32 param=0)=0> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool irr::video::IVideoDriver::writeImageToFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IImage *&nbsp;</td>
          <td class="mdname" nowrap> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const c8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>param</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Requires that there is a suitable image writer registered for writing the image. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Image to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Name of the file to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>Control parameter for the backend (e.g. compression level). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True on successful write. </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_i_video_driver_8h-source.html">IVideoDriver.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 19 18:54:21 2009 for Material System by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.3 </small></address>
</body>
</html>
